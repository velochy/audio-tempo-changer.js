{"version":3,"sources":["webpack://PhaseVocoder/webpack/universalModuleDefinition","webpack://PhaseVocoder/PhaseVocoder.min.js","webpack://PhaseVocoder/webpack/bootstrap","webpack://PhaseVocoder/./src/vector_helper.js","webpack://PhaseVocoder/./src/phase_vocoder.js","webpack://PhaseVocoder/./src/fft.js"],"names":["window","modules","__webpack_require__","moduleId","installedModules","exports","module","i","l","call","m","c","d","__webpack_require__.d","name","getter","o","Object","defineProperty","enumerable","get","r","__webpack_require__.r","Symbol","toStringTag","value","t","__webpack_require__.t","mode","__esModule","ns","create","key","bind","n","__webpack_require__.n","getDefault","getModuleExports","__webpack_require__.o","object","property","prototype","hasOwnProperty","p","s","VH","float_array","len","Float32Array","blit","src","spos","dest","dpos","set","subarray","FFT","PhaseVocoder","wsizeLog","tempo_ratio","pshift_rigid","frame_ind","re","im","p_re","p_im","ratio","CUR","PREV","prev_mags","b_mags","prev_np","b_npeaks","prpeaks","b_peaks","prev_in_angs","b_in_angs","prev_peak_adeltas","b_peak_adeltas","mags","length","peaks","max","thresh","MAX_PEAK_RATIO","n_peaks","prev_pi","f_delta","MAX_PEAK_JUMP","ppos","cur_np","cur_in_angs","cur_peak_adeltas","ci","pci","interpolate_phase","pi","cpi","Math","abs","round","MATCH_MAG_THRESH","in_angle","pred","PI","windowSize","pk","ana_len","pang","delta","ang","peaks_re","cos","peaks_im","sin","cp","cnp","cre","cim","nim","ind","floor","sgn","atan2","pow","fft","max_step_len","in_buffer","out_buffer","syn_len","win","hWS","re1","im1","re2","im2","pre2","pim2","qWS","push","f_ind","prev_out_len","syn_drift","syn_drift_per_step","gain_comp","obj","k","sum","GAIN_DEAMPLIFY","single_step_per_call","inbuffer_contains","unused_in_outbuf","outbuf","tail_end_calls","ceil","filler","outp","opos","outn","oi","left_over","out_len","n_needed","in_len","sdelta","m_re","m_im","inplace","unpack","repack","oblen","gc","ceiling","logN","m_N","m_logN","m_invN","m_revTgt","Array","x","y","twiddleRe","twiddleIm","wIndexStep","stage","wAngleInc","obj.inplace","inverse","numFlies","span","spacing","wMulRe","wMulIm","start","iTop","iBot","wRe","wIm","flyCount","xTopRe","xTopIm","xBotRe","xBotIm","tRe","i1","revI","buf","m_N2","obj.unpack","rre","rim","ire","iim","obj.repack","factory","define","amd","root"],"mappings":"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","file":"PhaseVocoder.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"PhaseVocoder\"] = factory();\n\telse\n\t\troot[\"PhaseVocoder\"] = factory();\n})(window, function() {\nreturn ","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"PhaseVocoder\"] = factory();\n\telse\n\t\troot[\"PhaseVocoder\"] = factory();\n})(window, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// define __esModule on exports\n/******/ \t__webpack_require__.r = function(exports) {\n/******/ \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n/******/ \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n/******/ \t\t}\n/******/ \t\tObject.defineProperty(exports, '__esModule', { value: true });\n/******/ \t};\n/******/\n/******/ \t// create a fake namespace object\n/******/ \t// mode & 1: value is a module id, require it\n/******/ \t// mode & 2: merge all properties of value into the ns\n/******/ \t// mode & 4: return value when already ns object\n/******/ \t// mode & 8|1: behave like require\n/******/ \t__webpack_require__.t = function(value, mode) {\n/******/ \t\tif(mode & 1) value = __webpack_require__(value);\n/******/ \t\tif(mode & 8) return value;\n/******/ \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n/******/ \t\tvar ns = Object.create(null);\n/******/ \t\t__webpack_require__.r(ns);\n/******/ \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n/******/ \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n/******/ \t\treturn ns;\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 1);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports) {\n\n\n// Define an allocator and blit function for float arrays\n// Can be used to achieve backwards compatibility down to dark ages pre IE 10 if needed\n// Also reduces code size a little with closure.\n\nvar VH = { \n\tfloat_array: function(len) { return new Float32Array(len); },\n\tblit: function(src, spos, dest, dpos, len) { dest.set(src.subarray(spos,spos+len),dpos); }\n};\n\n// Pre-IE10 versions:\n/*VH.prototype.float_array = function(len) { return new Array(len); }\nVH.prototype.blit = function(src, spos, dest, dpos, len) { for(var i=0;i<len;i++) dest[dpos+i] = src[spos+i]; };*/\n\nmodule.exports = VH;\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n/*\n * Phase Vocoder for changing tempo of audio without affecting pitch\n * Originally cross-compiled from HaXe\n *\n * Copyright (c) 2015-2019 Margus Niitsoo\n */\n\nvar VH = __webpack_require__(0);\nvar FFT = __webpack_require__(2);\n\nvar PhaseVocoder = function(wsizeLog, tempo_ratio) {\n\n\t// Default input values\n\tif (!wsizeLog) wsizeLog = 12; // 4096 - sensible default\n\tif (!tempo_ratio) tempo_ratio = 1.0;\n\n\t/**************************\n\t* Initialize variables\n\t**************************/\n\n\t// Some constants\n\tvar GAIN_DEAMPLIFY = 0.9; // Slightly lower the volume to avoid volume overflow-compression\n\tvar MAX_PEAK_RATIO = 1e-8; // Do not find peaks below this level: 80dB from max\n\tvar MAX_PEAK_JUMP = (Math.pow(2.0,50/1200.0)-1.0); // Rel distance (in freq) to look for matches\n\tvar MATCH_MAG_THRESH = 0.1; // New if mag_prev < MATCH_MAG_THRESH * mag_new\n\t\n\tvar windowSize = 1 << wsizeLog;\n\tvar fft = FFT(wsizeLog);\n\n\t// Caluclate max step size for both ana and syn windows\n\t// Has to be < 1/4 of window length or audible artifacts occur\n\tvar max_step_len = 1 << (wsizeLog - 2); // 1/4 of window_size\n\tmax_step_len -= max_step_len % 100; // Change to a multiple of 100 as tempo is often changed in percents\n\n\t//console.log(\"MAX STEP\",max_step_len,windowSize);\n\tvar in_buffer = VH.float_array(windowSize + max_step_len + 5);\n\tvar out_buffer = VH.float_array(windowSize + max_step_len + 5);\n\tvar ana_len = max_step_len, syn_len = max_step_len;\n\n\t// Hanning window\n\tvar win = VH.float_array(windowSize);\n\tfor(var i=0;i<windowSize;i++)\n\t\twin[i] = 0.5 * (1 - Math.cos(2 * Math.PI * i / windowSize));\n\n\tvar hWS = (windowSize >> 1) + 1;\n\tvar re1 = VH.float_array(hWS), im1 = VH.float_array(hWS);\n\tvar re2 = VH.float_array(hWS), im2 = VH.float_array(hWS);\n\tvar pre2 = VH.float_array(hWS), pim2 = VH.float_array(hWS);\n\n\tvar qWS = (hWS >> 1) + 1;\n\tvar b_npeaks = [0,0], b_peaks = [], b_in_angs = [], b_peak_adeltas = [];\n\tvar b_mags = [];\n\tfor(var i=0;i<2;i++) { // Double buffering\n\t\tb_peaks.push(VH.float_array(qWS));\n\t\tb_in_angs.push(VH.float_array(qWS));\n\t\tb_peak_adeltas.push(VH.float_array(qWS));\n\t\tb_mags.push(VH.float_array(hWS));\n\t}\n\t\n\tvar peaks_re = VH.float_array(qWS), peaks_im = VH.float_array(qWS);\n\n\tvar f_ind = 0, prev_out_len = 0;\n\tvar syn_drift = 0.0, syn_drift_per_step = 0.0;\n\tvar gain_comp = 1.0;\n\n\t// Small utility function to calculate gain compensation\n\tvar compute_gain_comp = function(win,syn_len) {\n\t\tvar n = win.length / syn_len | 0, sum = 0.0;\n\t\tfor(var i=0;i<n;i++) sum += win[i * syn_len];\n\t\treturn GAIN_DEAMPLIFY / sum;\n\t};\n\n\tvar obj = {};\n\tobj['resetBuffers'] = function() {\n\t\tf_ind = 0;\tprev_out_len = 0;\n\t\tsyn_drift = 0.0; b_npeaks = [0,0];\n\n\t\tfor(var i=0;i<2;i++)\n\t\t\tfor(var k=0;k<hWS;k++)\n\t\t\t\tb_mags[i][k] = 0.0;\n\n\t\tfor(var i=0;i<in_buffer.length;i++) in_buffer[i] = 0.0;\n\t\tfor(var i=0;i<out_buffer.length;i++) out_buffer[i] = 0.0;\n\t};\n\n\tobj['changeTempo'] = function(tempo_ratio) {\n\t\tana_len = syn_len = max_step_len;\n\t\tif(tempo_ratio >= 1.0) {\n\t\t\tsyn_len = Math.round(ana_len / tempo_ratio);\n\t\t} else {\n\t\t\tana_len = Math.round(syn_len * tempo_ratio);\n\t\t}\n\t\tsyn_drift_per_step = (1.0 / tempo_ratio - 1.0 * syn_len / ana_len) * ana_len;\n\t\tgain_comp = compute_gain_comp(win,syn_len);\n\n\t\t//console.log(\"TEMPO CHANGE\",tempo_ratio,\"LENS\",ana_len,syn_len,\"GAIN\",gain_comp);\n\t};\n\n\tobj['resetBuffers'](); obj['changeTempo'](tempo_ratio);\n\n\t/**************************\n\t* Small utility functions\n\t**************************/\n\t\n\t// Estimate the phase at (fractional) fft bin ind\n\tvar interpolate_phase = function(re,im,ind) {\n\t\tvar i = Math.floor(ind);\n\t\tvar sgn = i % 2 == 1 ? -1.0 : 1.0;\n\t\treturn Math.atan2(sgn * (im[i] - im[i + 1]),sgn * (re[i] - re[i + 1]));\n\t};\n\n\t// Get ang between -PI and PI\n\tvar unwrap = function(ang) {\n\t\treturn ang - 2 * Math.PI * Math.round(ang / (2 * Math.PI) );\n\t};\n\n\t// Try to estimate the phase change if window lengths differ by ratio\n\tvar estimate_phase_change = function(ang,k,pang,pk,ratio) {\n\t\tvar pred = 2 * Math.PI / windowSize * 0.5 * (pk + k) * ana_len;\n\t\tvar ywang = unwrap(ang - pang - pred);\n\n\t\treturn (ywang + pred) * ratio;\n\t};\n\n\t/**************************\n\t* Find peaks of spectrum\n\t**************************/\n\n\tvar find_rpeaks = function(mags,res) {\n\n\t\tvar max = 0; for(var i=0;i<mags.length;i++) if (mags[i]>max) max=mags[i];\n\t\tvar thresh = MAX_PEAK_RATIO * max;\n\n\t\tvar n_peaks = 1, prev_pi = 1; res[0] = 1.0;\n\t\tfor(var i=2;i<mags.length;i++) {\n\t\t\tvar f_delta = i * MAX_PEAK_JUMP;\n\t\t\tif(mags[i]>thresh && mags[i] > mags[i - 1] && mags[i] >= mags[i + 1]) { // Is local peak\n\n\t\t\t\t// Use quadratic interpolation to fine-tune the peak location\n\t\t\t\tvar ppos = i + (mags[i - 1] - mags[i + 1]) / (2 * (mags[i - 1] - 2 * mags[i] + mags[i + 1]));\n\n\t\t\t\t// If far enough from previous peak, add to list\n\t\t\t\tif(ppos - res[n_peaks - 1] > f_delta) { res[n_peaks++] = ppos; prev_pi = i; }\n\t\t\t\t// Else, if not far enough, but higher than previous, just replace prev \n\t\t\t\telse if(mags[i] > mags[prev_pi]) { res[n_peaks - 1] = ppos;\tprev_pi = i; }\n\t\t\t}\n\t\t}\n\t\treturn n_peaks;\n\t};\n\n\t/**************************\n\t* Rigid phase shift\n\t**************************/\n\n\tvar pshift_rigid = function(frame_ind,re,im,p_re,p_im,ratio) {\n\t\tvar CUR = frame_ind % 2, PREV = 1 - CUR;\n\n\t\tvar prev_mags = b_mags[PREV];\n\n\t\tvar prev_np = b_npeaks[PREV], prpeaks = b_peaks[PREV];\n\t\tvar prev_in_angs = b_in_angs[PREV], prev_peak_adeltas = b_peak_adeltas[PREV];\n\n\t\t// Calc new mags\n\t\tvar mags = b_mags[CUR];\n\t\tfor(var i=1;i<mags.length;i++) mags[i] = re[i] * re[i] + im[i] * im[i];\n\t\n\t\t// Find new peaks\n\t\tvar peaks = b_peaks[CUR];\n\t\tvar cur_np = b_npeaks[CUR] = find_rpeaks(mags,peaks);\n\n\t\t// Start adjusting angles\n\t\tvar cur_in_angs = b_in_angs[CUR], cur_peak_adeltas = b_peak_adeltas[CUR];\n\n\t\tif(frame_ind == 0 || cur_np == 0) { // If first frame (or no peaks)\n\n\t\t\t// Set out_ang = in_ang for all peaks\n\t\t\tfor(var ci=0;ci<cur_np;ci++) {\n\t\t\t\tvar pci = peaks[ci];\n\t\t\t\tprev_in_angs[ci] = prev_peak_adeltas[ci] = interpolate_phase(re,im,pci);\n\t\t\t}\n\t\t\t\n\t\t\treturn;\n\t\t}\n\n\t    /*********************************************************\n    \t* Match old peaks with new ones\n    \t* Also find where pmag*mag is max for next step\n    \t*********************************************************/\n\n\t\tvar pi = 0;\n\t\tfor(var ci=0;ci<cur_np;ci++) {\n\t\t\tvar pci = peaks[ci];\n\n\t\t\t// Scroll so peaks[ci] is between prpeaks[pi] and prpeaks[pi+1]\n\t\t\twhile(peaks[ci] > prpeaks[pi] && pi != prev_np) ++pi;\n\n\t\t\tvar cpi = pi;\n\t\t\tif(pi > 0 && pci - prpeaks[pi - 1] < prpeaks[pi] - pci) cpi = pi - 1;\n\n\t\t\tvar peak_delta = pci * MAX_PEAK_JUMP;\n\t\t\tif(Math.abs(prpeaks[cpi] - pci) < peak_delta && \n\t\t\t\tprev_mags[Math.round(prpeaks[cpi])] > \n\t\t\t\t\tMATCH_MAG_THRESH * mags[Math.round(pci)]) {\n\n\t\t\t\t// Found a matching peak in previous frame, so predict based on the diff\n\t\t\t\tvar in_angle = interpolate_phase(re,im,pci);\n\t\t\t\tvar out_angle = prev_in_angs[cpi] + prev_peak_adeltas[cpi] +\n\t\t\t\t\t\testimate_phase_change(in_angle,pci,prev_in_angs[cpi],prpeaks[cpi],ratio);\n\n\t\t\t\tvar delta = out_angle - in_angle;\n\t\t\t\tcur_in_angs[ci] = in_angle; cur_peak_adeltas[ci] = delta;\n\t\t\t\tpeaks_re[ci] = Math.cos(delta);\tpeaks_im[ci] = Math.sin(delta);\n\t\t\t} else { // Not matched - use the same phase as input\n\t\t\t\tcur_in_angs[ci] = interpolate_phase(re,im,pci);\n\t\t\t\tcur_peak_adeltas[ci] = 0; peaks_re[ci] = 1.0;\tpeaks_im[ci] = 0.0;\t\t\t\t\n\t\t\t}\n\t\t}\n\n\t    /********************************************************\n\t    * Adjust phase of all bins based on closest peak\n\t    *********************************************************/\n\n\t    // Add a \"dummy\" peak at the end of array\n\t\tpeaks[cur_np] = 2 * windowSize;\n\t\t\n\t\tvar cpi = 0, cp = peaks[cpi], cnp = peaks[cpi + 1];\n\t\tvar cre = peaks_re[cpi], cim = peaks_im[cpi];\n\n\t\tfor(var i=1;i<re.length-1;i++) {\n\t\t\tif(i >= cp && i - cp > cnp - i) {\n\t\t\t\t++cpi; cp = peaks[cpi];\tcnp = peaks[cpi + 1];\n\t\t\t\tcre = peaks_re[cpi]; cim = peaks_im[cpi];\n\t\t\t}\n\n\t\t\tvar nre = re[i] * cre - im[i] * cim;\n\t\t\tvar nim = re[i] * cim + im[i] * cre;\n\t\t\tre[i] = nre; im[i] = nim;\n\t\t}\n\t}\n\n\t/***********************************\n\t* Perform two syn/ana steps \n\t*\t(using the two-for-one fft trick)\n  \t* Takes windowSize + ana_len samples from in_buffer\n  \t*   and shifts in_buffer back by 2*ana_len\n  \t* Outputs <retval> samples to out_buffer\n\t***********************************/\n\n\tvar two_steps = function() {\n\n\t\t// To better match the given ratio,\n    \t// occasionally tweak syn_len by 1\n\t\tsyn_drift += 2 * syn_drift_per_step;\n\t\tvar sdelta = syn_drift | 0;\n\t\tsyn_drift -= sdelta;\n\t\t\n\t\t// Pack two steps into fft object\n\t\tfor(var i=0;i<windowSize;i++) {\n\t\t\tfft.m_re[i] = win[i] * in_buffer[i];\n\t\t\tfft.m_im[i] = win[i] * in_buffer[ana_len + i];\n\t\t}\n\n\t\t// Shift in_buffer back by 2*ana_len\n\t\tVH.blit(in_buffer,2*ana_len,\n            in_buffer,0,windowSize-ana_len);\n\n\t\t// Run the fft\n\t\tfft.inplace(false);\n\t\tfft.unpack(re1,im1,re2,im2);\n\n\t\t// Step 1 - move by syn_len\n\t\tvar ratio1 = 1.0 * syn_len / ana_len;\n\t\tpshift_rigid(f_ind,re1,im1,pre2,pim2,ratio1);\n\n\t\t// Step 2 - move by syn_len+sdelta\n\t\tvar ratio2 = 1.0 * (syn_len + sdelta) / ana_len;\n\t\tpshift_rigid(f_ind + 1,re2,im2,re1,im1,ratio2);\n\n\t\t// Save (modified) re and im\n\t\tVH.blit(re2,0,pre2,0,hWS); VH.blit(im2,0,pim2,0,hWS);\n\n\t\t// Run ifft\n\t\tfft.repack(re1,im1,re2,im2);\n\t\tfft.inplace(true);\n\n\t\t// Shift out_buffer back by previous out_len;\n\t\tvar oblen = out_buffer.length;\n\t\tVH.blit(out_buffer,prev_out_len,\n            out_buffer,0,oblen-prev_out_len);\n\t\t\n\t\t// And shift in zeros at the end\n\t\tfor(var i=oblen-prev_out_len;i<oblen;i++) out_buffer[i] = 0.0;\n\t\t\n\t\t// Value overflow protection - scale the packet if max above a threshold\n\t    // The distortion this creates is insignificant compared to phase issues\n\t\tvar max = 0.0, gc = gain_comp;\n\t\tfor(var i=0;i<syn_len;i++)\n\t\t\tif(Math.abs(2 * fft.m_re[i]) > max)\n\t\t\t\tmax = Math.abs(2 * fft.m_re[i]);\n\t\tfor(var i=0;i<windowSize-syn_len;i++)\n\t\t\tif(Math.abs(fft.m_re[i + syn_len + sdelta] + fft.m_im[i]) > max)\n\t\t\t\tmax = Math.abs(fft.m_re[i + syn_len + sdelta] + fft.m_im[i]);\n\n\t\tfor(var i=windowSize-syn_len;i<windowSize;i++)\n\t\t\tif(Math.abs(2 * fft.m_im[i]) > max)\n\t\t\t\tmax = Math.abs(2 * fft.m_im[i]);\n\n\t\t// Find allowed ceiling of a two-step sum and lower gain if needed\n\t\tvar ceiling = 1.0 / Math.floor(1.0 * windowSize / (2 * syn_len));\n\t\tif(gc * max > ceiling) {\n\t\t\t//console.log(\"Gain overflow, lowering volume: \",ceiling / max,gc,max);\n\t\t\tgc = ceiling / max;\n\t\t}\n\n\t\t// Write results to out_buffer\n\t\tfor(var i=0;i<windowSize;i++) {\n\t\t\tout_buffer[i] += gc * fft.m_re[i];\n\t\t\tout_buffer[i + syn_len + sdelta] += gc * fft.m_im[i];\n\t\t}\n\n\t\tf_ind += 2;\tprev_out_len = 2 * syn_len + sdelta;\n\n\t\treturn prev_out_len;\n\t}\n\n\tobj['stretch_filter'] = function(single_step_per_call) {\n\t\tvar inbuffer_contains = 0, unused_in_outbuf = 0;\n\t\tvar outbuf = VH.float_array(2 * max_step_len + 5);\n\n\t\tvar tail_end_calls = Math.ceil((windowSize - ana_len) / (2 * ana_len));\n\n\t\treturn function(filler) {\n\t\t\treturn function(outp,opos,outn) {\n\n\t\t\t\t// It constantly slightly overfills, so samples keep building up\n      \t\t\t// This is used to occasionally release the steam\n\t\t\t\tif(unused_in_outbuf >= outn) {\n\t\t\t\t\tVH.blit(outbuf,0,outp,opos,outn);\n\t\t\t\t\tVH.blit(outbuf,outn,outbuf,0,unused_in_outbuf);\n\t\t\t\t\treturn outn;\n\t\t\t\t}\n\n\t\t\t\tVH.blit(outbuf,0,outp,opos,unused_in_outbuf); // Copy full values to output\n\t\t\t\tvar oi = unused_in_outbuf;\n\t\t\t\t\n\t\t\t\tvar left_over = 0, out_len = 0;\n\t\t\t\twhile(true) {\n\n\t\t\t\t\t// Fetch new input samples\n\t\t\t\t\tvar n_needed = windowSize + ana_len - inbuffer_contains;\n\t\t\t\t\tif(n_needed >= 0) {\n\t\t\t\t\t\tvar in_len = filler(in_buffer,inbuffer_contains,n_needed);\n\t\t\t\t\t\tif(in_len < n_needed) {\n\t\t\t\t\t\t\tif(tail_end_calls == 0) break;\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tfor(var i=in_len-ana_len;i<ana_len;i++)\n\t\t\t\t\t\t\t\t\tin_buffer[windowSize + i] = 0.0;\n\t\t\t\t\t\t\t\ttail_end_calls -= 1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tinbuffer_contains = windowSize - ana_len;\n\t\t\t\t\t} else inbuffer_contains -= 2 * ana_len;\n\n\t\t\t\t\t// Run the vocoder\n\t\t\t\t\tout_len = two_steps();\n\n\t\t\t\t\t// Calculate how many samples are left over (usually 0)\n\t\t\t\t\tleft_over = oi + out_len - outn; if(left_over < 0) left_over = 0;\n\n\t\t\t\t\t// Copy fully ready samples out\n\t\t\t        VH.blit(out_buffer,0,outp,opos+oi,out_len-left_over);\n\n\t\t\t\t\toi += out_len;\n\t\t\t\t\t\n\t\t\t\t\tif(left_over > 0 || single_step_per_call) break;\n\t\t\t\t}\n\n\t\t\t\t// Copy left over samples to outbuf\n      \t\t\tVH.blit(out_buffer,out_len-left_over,outbuf,0,left_over);\n      \t\t\tunused_in_outbuf = left_over;\n\n\t\t\t\treturn oi;\n\t\t\t};\n\t\t};\n\t}\n\n\treturn obj;\n};\n\n/** @export */\nmodule.exports = PhaseVocoder;\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n/*\n * Performs an in-place complex FFT.\n * Adapted from FFT for ActionScript 3 written by Gerald T. Beauregard \n * (original ActionScript3 version, http://gerrybeauregard.wordpress.com/2010/08/03/an-even-faster-as3-fft/)\n *\n * Copyright (c) 2015-2019 Margus Niitsoo\n */\n\nvar VH = __webpack_require__(0);\n\nvar FFT = function(logN) {\n\n\t// Size of the buffer\n\tvar m_N = 1 << logN;\n\n\n\tvar obj = {\n\t\tm_logN : logN, m_N : m_N,\n\t\tm_invN : 1.0 / m_N,\n\t\tm_re : VH.float_array(m_N),\n\t\tm_im : VH.float_array(m_N),\n\t\tm_revTgt : new Array(m_N)\n\t}\n\n\t// Calculate bit reversals\n\tfor(var k = 0; k<m_N; k++) {\n\t\tvar x = k, y = 0;\n\t\tfor(var i=0;i<logN;i++) {\n\t\t\ty <<= 1;\n\t\t\ty |= x & 1;\n\t\t\tx >>= 1;\n\t\t}\n\t\tobj.m_revTgt[k] = y;\n\t}\n\n    // Compute a multiplier factor for the \"twiddle factors\".\n    // The twiddle factors are complex unit vectors spaced at\n    // regular angular intervals. The angle by which the twiddle\n    // factor advances depends on the FFT stage. In many FFT\n    // implementations the twiddle factors are cached.\n\n\tobj.twiddleRe = VH.float_array(obj.m_logN);\n\tobj.twiddleIm = VH.float_array(obj.m_logN);\n\n\tvar wIndexStep = 1;\n\tfor(var stage = 0; stage<obj.m_logN; stage++) {\n\t\tvar wAngleInc = 2.0 * wIndexStep * Math.PI * obj.m_invN;\n\t\tobj.twiddleRe[stage] = Math.cos(wAngleInc);\n\t\tobj.twiddleIm[stage] = Math.sin(wAngleInc);\n\t\twIndexStep <<= 1;\n\t}\n\n\t// In-place FFT function\n\tobj.inplace = function(inverse) {\n\n\t\tvar m_re = obj.m_re, m_im = obj.m_im;\n\t\tvar m_N = obj.m_N, m_logN = obj.m_logN;\n\n\t\tvar numFlies = m_N >> 1;\n\t\tvar span = m_N >> 1;\n\t\tvar spacing = m_N;\n\n\t\tif(inverse) {\n\t\t\tvar m_invN = 1.0/m_N;\n\t\t\tfor(var i=0; i<m_N; i++) {\n\t\t\t\tm_re[i] *= m_invN;\n\t\t\t\tm_im[i] *= m_invN;\n\t\t\t}\n\t\t}\n\n\t\t// For each stage of the FFT\n\t\tfor(var stage=0; stage<m_logN; stage++) {\n\t\t\tvar wMulRe = obj.twiddleRe[stage];\n\t\t\tvar wMulIm = obj.twiddleIm[stage];\n\t\t\tif(!inverse) wMulIm *= -1;\n\n\t\t\tvar start = 0;\n\t\t\twhile(start < m_N) {\n\t\t\t\tvar iTop = start, iBot = start + span;\n\t\t\t\tvar wRe = 1.0, wIm = 0.0;\n\n\t\t\t\t// For each butterfly in this stage\n\t\t\t\tfor(var flyCount=0; flyCount<numFlies; flyCount++) {\n\t\t\t\t\t// Get the top & bottom values\n\t\t\t\t\tvar xTopRe = m_re[iTop];\n\t\t\t\t\tvar xTopIm = m_im[iTop];\n\t\t\t\t\tvar xBotRe = m_re[iBot];\n\t\t\t\t\tvar xBotIm = m_im[iBot];\n\n\t\t\t\t\t// Top branch of butterfly has addition\n\t\t\t\t\tm_re[iTop] = xTopRe + xBotRe;\n\t\t\t\t\tm_im[iTop] = xTopIm + xBotIm;\n\n\t\t\t\t\t// Bottom branch of butterly has subtraction,\n                    // followed by multiplication by twiddle factor\n\t\t\t\t\txBotRe = xTopRe - xBotRe;\n\t\t\t\t\txBotIm = xTopIm - xBotIm;\n\n\t\t\t\t\tm_re[iBot] = xBotRe * wRe - xBotIm * wIm;\n\t\t\t\t\tm_im[iBot] = xBotRe * wIm + xBotIm * wRe;\n\n\t\t\t\t\t// Advance butterfly to next top & bottom positions\n                    iTop++;\n                    iBot++;\n\n                    // Update the twiddle factor, via complex multiply\n                    // by unit vector with the appropriate angle\n                    // (wRe + j wIm) = (wRe + j wIm) x (wMulRe + j wMulIm)\n\t\t\t\t\tvar tRe = wRe;\n\t\t\t\t\twRe = wRe * wMulRe - wIm * wMulIm;\n\t\t\t\t\twIm = tRe * wMulIm + wIm * wMulRe;\n\t\t\t\t}\n\t\t\t\tstart += spacing;\n\t\t\t}\n\t\t\tnumFlies >>= 1;\n\t\t\tspan >>= 1;\n\t\t\tspacing >>= 1;\n\t\t}\n\n\t\tvar revI, buf, m_revTgt = obj.m_revTgt;\n\t\tfor(var i1=0; i1<m_N; i1++)\n\t\t\tif(m_revTgt[i1] > i1) {\n                // Bit-Reversal is an involution i.e.\n                // x.revTgt.revTgt==x\n                // So switching values around\n                // restores the original order\n\t\t\t\trevI = m_revTgt[i1];\n\t\t\t\tbuf = m_re[revI];\n\t\t\t\tm_re[revI] = m_re[i1];\n\t\t\t\tm_re[i1] = buf;\n\t\t\t\tbuf = m_im[revI];\n\t\t\t\tm_im[revI] = m_im[i1];\n\t\t\t\tm_im[i1] = buf;\n\t\t\t}\n\t}\n\n\tvar m_N2 = m_N >> 1; // m_N/2 needed in un/repack below\n\n\t// Two-for-one trick for real-valued FFT:\n\t// Put one series in re, other in im, run \"inplace\",\n\t// then call this \"unpack\" function\n\tobj.unpack = function(rre,rim,ire,iim) {\n\t\trre[0] = obj.m_re[0]; ire[0] = obj.m_im[0];\n\t\trim[0] = iim[0] = 0;\n\t\trre[m_N2] = obj.m_re[m_N2];\n\t\tire[m_N2] = obj.m_im[m_N2];\n\t\trim[m_N2] = iim[m_N2] = 0;\n\t\tfor(var i = 1;i<m_N2;i++) {\n\t\t\trre[i] = (obj.m_re[i] + obj.m_re[m_N - i]) / 2;\n\t\t\trim[i] = (obj.m_im[i] - obj.m_im[m_N - i]) / 2;\n\t\t\tire[i] = (obj.m_im[i] + obj.m_im[m_N - i]) / 2;\n\t\t\tiim[i] = (-obj.m_re[i] + obj.m_re[m_N - i]) / 2;\n\t\t}\n\t}\n\t\n\t// The two-for-one trick if you know results are real-valued\n\t// Call \"repack\", then fft.inplace(true) and you have\n\t// First fft in re and second in im\n\tobj.repack = function(rre,rim,ire,iim) {\n\t\tobj.m_re[0] = rre[0]; obj.m_im[0] = ire[0];\n\t\tobj.m_re[m_N2] = rre[m_N2]; obj.m_im[m_N2] = ire[m_N2];\n\t\tfor(var i = 1;i<m_N2;i++) {\n\t\t\tobj.m_re[i] = rre[i] - iim[i];\n\t\t\tobj.m_im[i] = rim[i] + ire[i];\n\t\t\tobj.m_re[m_N - i] = rre[i] + iim[i];\n\t\t\tobj.m_im[m_N - i] = -rim[i] + ire[i];\n\t\t}\n\t}\n\n\treturn obj;\n};\n\nmodule.exports = FFT;\n\n/***/ })\n/******/ ]);\n});"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 1);\n","\n// Define an allocator and blit function for float arrays\n// Can be used to achieve backwards compatibility down to dark ages pre IE 10 if needed\n// Also reduces code size a little with closure.\n\nvar VH = { \n\tfloat_array: function(len) { return new Float32Array(len); },\n\tblit: function(src, spos, dest, dpos, len) { dest.set(src.subarray(spos,spos+len),dpos); }\n};\n\n// Pre-IE10 versions:\n/*VH.prototype.float_array = function(len) { return new Array(len); }\nVH.prototype.blit = function(src, spos, dest, dpos, len) { for(var i=0;i<len;i++) dest[dpos+i] = src[spos+i]; };*/\n\nmodule.exports = VH;","'use strict';\n\n/*\n * Phase Vocoder for changing tempo of audio without affecting pitch\n * Originally cross-compiled from HaXe\n *\n * Copyright (c) 2015-2019 Margus Niitsoo\n */\n\nvar VH = require('./vector_helper.js');\nvar FFT = require('./fft.js');\n\nvar PhaseVocoder = function(wsizeLog, tempo_ratio) {\n\n\t// Default input values\n\tif (!wsizeLog) wsizeLog = 12; // 4096 - sensible default\n\tif (!tempo_ratio) tempo_ratio = 1.0;\n\n\t/**************************\n\t* Initialize variables\n\t**************************/\n\n\t// Some constants\n\tvar GAIN_DEAMPLIFY = 0.9; // Slightly lower the volume to avoid volume overflow-compression\n\tvar MAX_PEAK_RATIO = 1e-8; // Do not find peaks below this level: 80dB from max\n\tvar MAX_PEAK_JUMP = (Math.pow(2.0,50/1200.0)-1.0); // Rel distance (in freq) to look for matches\n\tvar MATCH_MAG_THRESH = 0.1; // New if mag_prev < MATCH_MAG_THRESH * mag_new\n\t\n\tvar windowSize = 1 << wsizeLog;\n\tvar fft = FFT(wsizeLog);\n\n\t// Caluclate max step size for both ana and syn windows\n\t// Has to be < 1/4 of window length or audible artifacts occur\n\tvar max_step_len = 1 << (wsizeLog - 2); // 1/4 of window_size\n\tmax_step_len -= max_step_len % 100; // Change to a multiple of 100 as tempo is often changed in percents\n\n\t//console.log(\"MAX STEP\",max_step_len,windowSize);\n\tvar in_buffer = VH.float_array(windowSize + max_step_len + 5);\n\tvar out_buffer = VH.float_array(windowSize + max_step_len + 5);\n\tvar ana_len = max_step_len, syn_len = max_step_len;\n\n\t// Hanning window\n\tvar win = VH.float_array(windowSize);\n\tfor(var i=0;i<windowSize;i++)\n\t\twin[i] = 0.5 * (1 - Math.cos(2 * Math.PI * i / windowSize));\n\n\tvar hWS = (windowSize >> 1) + 1;\n\tvar re1 = VH.float_array(hWS), im1 = VH.float_array(hWS);\n\tvar re2 = VH.float_array(hWS), im2 = VH.float_array(hWS);\n\tvar pre2 = VH.float_array(hWS), pim2 = VH.float_array(hWS);\n\n\tvar qWS = (hWS >> 1) + 1;\n\tvar b_npeaks = [0,0], b_peaks = [], b_in_angs = [], b_peak_adeltas = [];\n\tvar b_mags = [];\n\tfor(var i=0;i<2;i++) { // Double buffering\n\t\tb_peaks.push(VH.float_array(qWS));\n\t\tb_in_angs.push(VH.float_array(qWS));\n\t\tb_peak_adeltas.push(VH.float_array(qWS));\n\t\tb_mags.push(VH.float_array(hWS));\n\t}\n\t\n\tvar peaks_re = VH.float_array(qWS), peaks_im = VH.float_array(qWS);\n\n\tvar f_ind = 0, prev_out_len = 0;\n\tvar syn_drift = 0.0, syn_drift_per_step = 0.0;\n\tvar gain_comp = 1.0;\n\n\t// Small utility function to calculate gain compensation\n\tvar compute_gain_comp = function(win,syn_len) {\n\t\tvar n = win.length / syn_len | 0, sum = 0.0;\n\t\tfor(var i=0;i<n;i++) sum += win[i * syn_len];\n\t\treturn GAIN_DEAMPLIFY / sum;\n\t};\n\n\tvar obj = {};\n\tobj['resetBuffers'] = function() {\n\t\tf_ind = 0;\tprev_out_len = 0;\n\t\tsyn_drift = 0.0; b_npeaks = [0,0];\n\n\t\tfor(var i=0;i<2;i++)\n\t\t\tfor(var k=0;k<hWS;k++)\n\t\t\t\tb_mags[i][k] = 0.0;\n\n\t\tfor(var i=0;i<in_buffer.length;i++) in_buffer[i] = 0.0;\n\t\tfor(var i=0;i<out_buffer.length;i++) out_buffer[i] = 0.0;\n\t};\n\n\tobj['changeTempo'] = function(tempo_ratio) {\n\t\tana_len = syn_len = max_step_len;\n\t\tif(tempo_ratio >= 1.0) {\n\t\t\tsyn_len = Math.round(ana_len / tempo_ratio);\n\t\t} else {\n\t\t\tana_len = Math.round(syn_len * tempo_ratio);\n\t\t}\n\t\tsyn_drift_per_step = (1.0 / tempo_ratio - 1.0 * syn_len / ana_len) * ana_len;\n\t\tgain_comp = compute_gain_comp(win,syn_len);\n\n\t\t//console.log(\"TEMPO CHANGE\",tempo_ratio,\"LENS\",ana_len,syn_len,\"GAIN\",gain_comp);\n\t};\n\n\tobj['resetBuffers'](); obj['changeTempo'](tempo_ratio);\n\n\t/**************************\n\t* Small utility functions\n\t**************************/\n\t\n\t// Estimate the phase at (fractional) fft bin ind\n\tvar interpolate_phase = function(re,im,ind) {\n\t\tvar i = Math.floor(ind);\n\t\tvar sgn = i % 2 == 1 ? -1.0 : 1.0;\n\t\treturn Math.atan2(sgn * (im[i] - im[i + 1]),sgn * (re[i] - re[i + 1]));\n\t};\n\n\t// Get ang between -PI and PI\n\tvar unwrap = function(ang) {\n\t\treturn ang - 2 * Math.PI * Math.round(ang / (2 * Math.PI) );\n\t};\n\n\t// Try to estimate the phase change if window lengths differ by ratio\n\tvar estimate_phase_change = function(ang,k,pang,pk,ratio) {\n\t\tvar pred = 2 * Math.PI / windowSize * 0.5 * (pk + k) * ana_len;\n\t\tvar ywang = unwrap(ang - pang - pred);\n\n\t\treturn (ywang + pred) * ratio;\n\t};\n\n\t/**************************\n\t* Find peaks of spectrum\n\t**************************/\n\n\tvar find_rpeaks = function(mags,res) {\n\n\t\tvar max = 0; for(var i=0;i<mags.length;i++) if (mags[i]>max) max=mags[i];\n\t\tvar thresh = MAX_PEAK_RATIO * max;\n\n\t\tvar n_peaks = 1, prev_pi = 1; res[0] = 1.0;\n\t\tfor(var i=2;i<mags.length;i++) {\n\t\t\tvar f_delta = i * MAX_PEAK_JUMP;\n\t\t\tif(mags[i]>thresh && mags[i] > mags[i - 1] && mags[i] >= mags[i + 1]) { // Is local peak\n\n\t\t\t\t// Use quadratic interpolation to fine-tune the peak location\n\t\t\t\tvar ppos = i + (mags[i - 1] - mags[i + 1]) / (2 * (mags[i - 1] - 2 * mags[i] + mags[i + 1]));\n\n\t\t\t\t// If far enough from previous peak, add to list\n\t\t\t\tif(ppos - res[n_peaks - 1] > f_delta) { res[n_peaks++] = ppos; prev_pi = i; }\n\t\t\t\t// Else, if not far enough, but higher than previous, just replace prev \n\t\t\t\telse if(mags[i] > mags[prev_pi]) { res[n_peaks - 1] = ppos;\tprev_pi = i; }\n\t\t\t}\n\t\t}\n\t\treturn n_peaks;\n\t};\n\n\t/**************************\n\t* Rigid phase shift\n\t**************************/\n\n\tvar pshift_rigid = function(frame_ind,re,im,p_re,p_im,ratio) {\n\t\tvar CUR = frame_ind % 2, PREV = 1 - CUR;\n\n\t\tvar prev_mags = b_mags[PREV];\n\n\t\tvar prev_np = b_npeaks[PREV], prpeaks = b_peaks[PREV];\n\t\tvar prev_in_angs = b_in_angs[PREV], prev_peak_adeltas = b_peak_adeltas[PREV];\n\n\t\t// Calc new mags\n\t\tvar mags = b_mags[CUR];\n\t\tfor(var i=1;i<mags.length;i++) mags[i] = re[i] * re[i] + im[i] * im[i];\n\t\n\t\t// Find new peaks\n\t\tvar peaks = b_peaks[CUR];\n\t\tvar cur_np = b_npeaks[CUR] = find_rpeaks(mags,peaks);\n\n\t\t// Start adjusting angles\n\t\tvar cur_in_angs = b_in_angs[CUR], cur_peak_adeltas = b_peak_adeltas[CUR];\n\n\t\tif(frame_ind == 0 || cur_np == 0) { // If first frame (or no peaks)\n\n\t\t\t// Set out_ang = in_ang for all peaks\n\t\t\tfor(var ci=0;ci<cur_np;ci++) {\n\t\t\t\tvar pci = peaks[ci];\n\t\t\t\tprev_in_angs[ci] = prev_peak_adeltas[ci] = interpolate_phase(re,im,pci);\n\t\t\t}\n\t\t\t\n\t\t\treturn;\n\t\t}\n\n\t    /*********************************************************\n    \t* Match old peaks with new ones\n    \t* Also find where pmag*mag is max for next step\n    \t*********************************************************/\n\n\t\tvar pi = 0;\n\t\tfor(var ci=0;ci<cur_np;ci++) {\n\t\t\tvar pci = peaks[ci];\n\n\t\t\t// Scroll so peaks[ci] is between prpeaks[pi] and prpeaks[pi+1]\n\t\t\twhile(peaks[ci] > prpeaks[pi] && pi != prev_np) ++pi;\n\n\t\t\tvar cpi = pi;\n\t\t\tif(pi > 0 && pci - prpeaks[pi - 1] < prpeaks[pi] - pci) cpi = pi - 1;\n\n\t\t\tvar peak_delta = pci * MAX_PEAK_JUMP;\n\t\t\tif(Math.abs(prpeaks[cpi] - pci) < peak_delta && \n\t\t\t\tprev_mags[Math.round(prpeaks[cpi])] > \n\t\t\t\t\tMATCH_MAG_THRESH * mags[Math.round(pci)]) {\n\n\t\t\t\t// Found a matching peak in previous frame, so predict based on the diff\n\t\t\t\tvar in_angle = interpolate_phase(re,im,pci);\n\t\t\t\tvar out_angle = prev_in_angs[cpi] + prev_peak_adeltas[cpi] +\n\t\t\t\t\t\testimate_phase_change(in_angle,pci,prev_in_angs[cpi],prpeaks[cpi],ratio);\n\n\t\t\t\tvar delta = out_angle - in_angle;\n\t\t\t\tcur_in_angs[ci] = in_angle; cur_peak_adeltas[ci] = delta;\n\t\t\t\tpeaks_re[ci] = Math.cos(delta);\tpeaks_im[ci] = Math.sin(delta);\n\t\t\t} else { // Not matched - use the same phase as input\n\t\t\t\tcur_in_angs[ci] = interpolate_phase(re,im,pci);\n\t\t\t\tcur_peak_adeltas[ci] = 0; peaks_re[ci] = 1.0;\tpeaks_im[ci] = 0.0;\t\t\t\t\n\t\t\t}\n\t\t}\n\n\t    /********************************************************\n\t    * Adjust phase of all bins based on closest peak\n\t    *********************************************************/\n\n\t    // Add a \"dummy\" peak at the end of array\n\t\tpeaks[cur_np] = 2 * windowSize;\n\t\t\n\t\tvar cpi = 0, cp = peaks[cpi], cnp = peaks[cpi + 1];\n\t\tvar cre = peaks_re[cpi], cim = peaks_im[cpi];\n\n\t\tfor(var i=1;i<re.length-1;i++) {\n\t\t\tif(i >= cp && i - cp > cnp - i) {\n\t\t\t\t++cpi; cp = peaks[cpi];\tcnp = peaks[cpi + 1];\n\t\t\t\tcre = peaks_re[cpi]; cim = peaks_im[cpi];\n\t\t\t}\n\n\t\t\tvar nre = re[i] * cre - im[i] * cim;\n\t\t\tvar nim = re[i] * cim + im[i] * cre;\n\t\t\tre[i] = nre; im[i] = nim;\n\t\t}\n\t}\n\n\t/***********************************\n\t* Perform two syn/ana steps \n\t*\t(using the two-for-one fft trick)\n  \t* Takes windowSize + ana_len samples from in_buffer\n  \t*   and shifts in_buffer back by 2*ana_len\n  \t* Outputs <retval> samples to out_buffer\n\t***********************************/\n\n\tvar two_steps = function() {\n\n\t\t// To better match the given ratio,\n    \t// occasionally tweak syn_len by 1\n\t\tsyn_drift += 2 * syn_drift_per_step;\n\t\tvar sdelta = syn_drift | 0;\n\t\tsyn_drift -= sdelta;\n\t\t\n\t\t// Pack two steps into fft object\n\t\tfor(var i=0;i<windowSize;i++) {\n\t\t\tfft.m_re[i] = win[i] * in_buffer[i];\n\t\t\tfft.m_im[i] = win[i] * in_buffer[ana_len + i];\n\t\t}\n\n\t\t// Shift in_buffer back by 2*ana_len\n\t\tVH.blit(in_buffer,2*ana_len,\n            in_buffer,0,windowSize-ana_len);\n\n\t\t// Run the fft\n\t\tfft.inplace(false);\n\t\tfft.unpack(re1,im1,re2,im2);\n\n\t\t// Step 1 - move by syn_len\n\t\tvar ratio1 = 1.0 * syn_len / ana_len;\n\t\tpshift_rigid(f_ind,re1,im1,pre2,pim2,ratio1);\n\n\t\t// Step 2 - move by syn_len+sdelta\n\t\tvar ratio2 = 1.0 * (syn_len + sdelta) / ana_len;\n\t\tpshift_rigid(f_ind + 1,re2,im2,re1,im1,ratio2);\n\n\t\t// Save (modified) re and im\n\t\tVH.blit(re2,0,pre2,0,hWS); VH.blit(im2,0,pim2,0,hWS);\n\n\t\t// Run ifft\n\t\tfft.repack(re1,im1,re2,im2);\n\t\tfft.inplace(true);\n\n\t\t// Shift out_buffer back by previous out_len;\n\t\tvar oblen = out_buffer.length;\n\t\tVH.blit(out_buffer,prev_out_len,\n            out_buffer,0,oblen-prev_out_len);\n\t\t\n\t\t// And shift in zeros at the end\n\t\tfor(var i=oblen-prev_out_len;i<oblen;i++) out_buffer[i] = 0.0;\n\t\t\n\t\t// Value overflow protection - scale the packet if max above a threshold\n\t    // The distortion this creates is insignificant compared to phase issues\n\t\tvar max = 0.0, gc = gain_comp;\n\t\tfor(var i=0;i<syn_len;i++)\n\t\t\tif(Math.abs(2 * fft.m_re[i]) > max)\n\t\t\t\tmax = Math.abs(2 * fft.m_re[i]);\n\t\tfor(var i=0;i<windowSize-syn_len;i++)\n\t\t\tif(Math.abs(fft.m_re[i + syn_len + sdelta] + fft.m_im[i]) > max)\n\t\t\t\tmax = Math.abs(fft.m_re[i + syn_len + sdelta] + fft.m_im[i]);\n\n\t\tfor(var i=windowSize-syn_len;i<windowSize;i++)\n\t\t\tif(Math.abs(2 * fft.m_im[i]) > max)\n\t\t\t\tmax = Math.abs(2 * fft.m_im[i]);\n\n\t\t// Find allowed ceiling of a two-step sum and lower gain if needed\n\t\tvar ceiling = 1.0 / Math.floor(1.0 * windowSize / (2 * syn_len));\n\t\tif(gc * max > ceiling) {\n\t\t\t//console.log(\"Gain overflow, lowering volume: \",ceiling / max,gc,max);\n\t\t\tgc = ceiling / max;\n\t\t}\n\n\t\t// Write results to out_buffer\n\t\tfor(var i=0;i<windowSize;i++) {\n\t\t\tout_buffer[i] += gc * fft.m_re[i];\n\t\t\tout_buffer[i + syn_len + sdelta] += gc * fft.m_im[i];\n\t\t}\n\n\t\tf_ind += 2;\tprev_out_len = 2 * syn_len + sdelta;\n\n\t\treturn prev_out_len;\n\t}\n\n\tobj['stretch_filter'] = function(single_step_per_call) {\n\t\tvar inbuffer_contains = 0, unused_in_outbuf = 0;\n\t\tvar outbuf = VH.float_array(2 * max_step_len + 5);\n\n\t\tvar tail_end_calls = Math.ceil((windowSize - ana_len) / (2 * ana_len));\n\n\t\treturn function(filler) {\n\t\t\treturn function(outp,opos,outn) {\n\n\t\t\t\t// It constantly slightly overfills, so samples keep building up\n      \t\t\t// This is used to occasionally release the steam\n\t\t\t\tif(unused_in_outbuf >= outn) {\n\t\t\t\t\tVH.blit(outbuf,0,outp,opos,outn);\n\t\t\t\t\tVH.blit(outbuf,outn,outbuf,0,unused_in_outbuf);\n\t\t\t\t\treturn outn;\n\t\t\t\t}\n\n\t\t\t\tVH.blit(outbuf,0,outp,opos,unused_in_outbuf); // Copy full values to output\n\t\t\t\tvar oi = unused_in_outbuf;\n\t\t\t\t\n\t\t\t\tvar left_over = 0, out_len = 0;\n\t\t\t\twhile(true) {\n\n\t\t\t\t\t// Fetch new input samples\n\t\t\t\t\tvar n_needed = windowSize + ana_len - inbuffer_contains;\n\t\t\t\t\tif(n_needed >= 0) {\n\t\t\t\t\t\tvar in_len = filler(in_buffer,inbuffer_contains,n_needed);\n\t\t\t\t\t\tif(in_len < n_needed) {\n\t\t\t\t\t\t\tif(tail_end_calls == 0) break;\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tfor(var i=in_len-ana_len;i<ana_len;i++)\n\t\t\t\t\t\t\t\t\tin_buffer[windowSize + i] = 0.0;\n\t\t\t\t\t\t\t\ttail_end_calls -= 1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tinbuffer_contains = windowSize - ana_len;\n\t\t\t\t\t} else inbuffer_contains -= 2 * ana_len;\n\n\t\t\t\t\t// Run the vocoder\n\t\t\t\t\tout_len = two_steps();\n\n\t\t\t\t\t// Calculate how many samples are left over (usually 0)\n\t\t\t\t\tleft_over = oi + out_len - outn; if(left_over < 0) left_over = 0;\n\n\t\t\t\t\t// Copy fully ready samples out\n\t\t\t        VH.blit(out_buffer,0,outp,opos+oi,out_len-left_over);\n\n\t\t\t\t\toi += out_len;\n\t\t\t\t\t\n\t\t\t\t\tif(left_over > 0 || single_step_per_call) break;\n\t\t\t\t}\n\n\t\t\t\t// Copy left over samples to outbuf\n      \t\t\tVH.blit(out_buffer,out_len-left_over,outbuf,0,left_over);\n      \t\t\tunused_in_outbuf = left_over;\n\n\t\t\t\treturn oi;\n\t\t\t};\n\t\t};\n\t}\n\n\treturn obj;\n};\n\n/** @export */\nmodule.exports = PhaseVocoder;","'use strict';\n\n/*\n * Performs an in-place complex FFT.\n * Adapted from FFT for ActionScript 3 written by Gerald T. Beauregard \n * (original ActionScript3 version, http://gerrybeauregard.wordpress.com/2010/08/03/an-even-faster-as3-fft/)\n *\n * Copyright (c) 2015-2019 Margus Niitsoo\n */\n\nvar VH = require('./vector_helper.js');\n\nvar FFT = function(logN) {\n\n\t// Size of the buffer\n\tvar m_N = 1 << logN;\n\n\n\tvar obj = {\n\t\tm_logN : logN, m_N : m_N,\n\t\tm_invN : 1.0 / m_N,\n\t\tm_re : VH.float_array(m_N),\n\t\tm_im : VH.float_array(m_N),\n\t\tm_revTgt : new Array(m_N)\n\t}\n\n\t// Calculate bit reversals\n\tfor(var k = 0; k<m_N; k++) {\n\t\tvar x = k, y = 0;\n\t\tfor(var i=0;i<logN;i++) {\n\t\t\ty <<= 1;\n\t\t\ty |= x & 1;\n\t\t\tx >>= 1;\n\t\t}\n\t\tobj.m_revTgt[k] = y;\n\t}\n\n    // Compute a multiplier factor for the \"twiddle factors\".\n    // The twiddle factors are complex unit vectors spaced at\n    // regular angular intervals. The angle by which the twiddle\n    // factor advances depends on the FFT stage. In many FFT\n    // implementations the twiddle factors are cached.\n\n\tobj.twiddleRe = VH.float_array(obj.m_logN);\n\tobj.twiddleIm = VH.float_array(obj.m_logN);\n\n\tvar wIndexStep = 1;\n\tfor(var stage = 0; stage<obj.m_logN; stage++) {\n\t\tvar wAngleInc = 2.0 * wIndexStep * Math.PI * obj.m_invN;\n\t\tobj.twiddleRe[stage] = Math.cos(wAngleInc);\n\t\tobj.twiddleIm[stage] = Math.sin(wAngleInc);\n\t\twIndexStep <<= 1;\n\t}\n\n\t// In-place FFT function\n\tobj.inplace = function(inverse) {\n\n\t\tvar m_re = obj.m_re, m_im = obj.m_im;\n\t\tvar m_N = obj.m_N, m_logN = obj.m_logN;\n\n\t\tvar numFlies = m_N >> 1;\n\t\tvar span = m_N >> 1;\n\t\tvar spacing = m_N;\n\n\t\tif(inverse) {\n\t\t\tvar m_invN = 1.0/m_N;\n\t\t\tfor(var i=0; i<m_N; i++) {\n\t\t\t\tm_re[i] *= m_invN;\n\t\t\t\tm_im[i] *= m_invN;\n\t\t\t}\n\t\t}\n\n\t\t// For each stage of the FFT\n\t\tfor(var stage=0; stage<m_logN; stage++) {\n\t\t\tvar wMulRe = obj.twiddleRe[stage];\n\t\t\tvar wMulIm = obj.twiddleIm[stage];\n\t\t\tif(!inverse) wMulIm *= -1;\n\n\t\t\tvar start = 0;\n\t\t\twhile(start < m_N) {\n\t\t\t\tvar iTop = start, iBot = start + span;\n\t\t\t\tvar wRe = 1.0, wIm = 0.0;\n\n\t\t\t\t// For each butterfly in this stage\n\t\t\t\tfor(var flyCount=0; flyCount<numFlies; flyCount++) {\n\t\t\t\t\t// Get the top & bottom values\n\t\t\t\t\tvar xTopRe = m_re[iTop];\n\t\t\t\t\tvar xTopIm = m_im[iTop];\n\t\t\t\t\tvar xBotRe = m_re[iBot];\n\t\t\t\t\tvar xBotIm = m_im[iBot];\n\n\t\t\t\t\t// Top branch of butterfly has addition\n\t\t\t\t\tm_re[iTop] = xTopRe + xBotRe;\n\t\t\t\t\tm_im[iTop] = xTopIm + xBotIm;\n\n\t\t\t\t\t// Bottom branch of butterly has subtraction,\n                    // followed by multiplication by twiddle factor\n\t\t\t\t\txBotRe = xTopRe - xBotRe;\n\t\t\t\t\txBotIm = xTopIm - xBotIm;\n\n\t\t\t\t\tm_re[iBot] = xBotRe * wRe - xBotIm * wIm;\n\t\t\t\t\tm_im[iBot] = xBotRe * wIm + xBotIm * wRe;\n\n\t\t\t\t\t// Advance butterfly to next top & bottom positions\n                    iTop++;\n                    iBot++;\n\n                    // Update the twiddle factor, via complex multiply\n                    // by unit vector with the appropriate angle\n                    // (wRe + j wIm) = (wRe + j wIm) x (wMulRe + j wMulIm)\n\t\t\t\t\tvar tRe = wRe;\n\t\t\t\t\twRe = wRe * wMulRe - wIm * wMulIm;\n\t\t\t\t\twIm = tRe * wMulIm + wIm * wMulRe;\n\t\t\t\t}\n\t\t\t\tstart += spacing;\n\t\t\t}\n\t\t\tnumFlies >>= 1;\n\t\t\tspan >>= 1;\n\t\t\tspacing >>= 1;\n\t\t}\n\n\t\tvar revI, buf, m_revTgt = obj.m_revTgt;\n\t\tfor(var i1=0; i1<m_N; i1++)\n\t\t\tif(m_revTgt[i1] > i1) {\n                // Bit-Reversal is an involution i.e.\n                // x.revTgt.revTgt==x\n                // So switching values around\n                // restores the original order\n\t\t\t\trevI = m_revTgt[i1];\n\t\t\t\tbuf = m_re[revI];\n\t\t\t\tm_re[revI] = m_re[i1];\n\t\t\t\tm_re[i1] = buf;\n\t\t\t\tbuf = m_im[revI];\n\t\t\t\tm_im[revI] = m_im[i1];\n\t\t\t\tm_im[i1] = buf;\n\t\t\t}\n\t}\n\n\tvar m_N2 = m_N >> 1; // m_N/2 needed in un/repack below\n\n\t// Two-for-one trick for real-valued FFT:\n\t// Put one series in re, other in im, run \"inplace\",\n\t// then call this \"unpack\" function\n\tobj.unpack = function(rre,rim,ire,iim) {\n\t\trre[0] = obj.m_re[0]; ire[0] = obj.m_im[0];\n\t\trim[0] = iim[0] = 0;\n\t\trre[m_N2] = obj.m_re[m_N2];\n\t\tire[m_N2] = obj.m_im[m_N2];\n\t\trim[m_N2] = iim[m_N2] = 0;\n\t\tfor(var i = 1;i<m_N2;i++) {\n\t\t\trre[i] = (obj.m_re[i] + obj.m_re[m_N - i]) / 2;\n\t\t\trim[i] = (obj.m_im[i] - obj.m_im[m_N - i]) / 2;\n\t\t\tire[i] = (obj.m_im[i] + obj.m_im[m_N - i]) / 2;\n\t\t\tiim[i] = (-obj.m_re[i] + obj.m_re[m_N - i]) / 2;\n\t\t}\n\t}\n\t\n\t// The two-for-one trick if you know results are real-valued\n\t// Call \"repack\", then fft.inplace(true) and you have\n\t// First fft in re and second in im\n\tobj.repack = function(rre,rim,ire,iim) {\n\t\tobj.m_re[0] = rre[0]; obj.m_im[0] = ire[0];\n\t\tobj.m_re[m_N2] = rre[m_N2]; obj.m_im[m_N2] = ire[m_N2];\n\t\tfor(var i = 1;i<m_N2;i++) {\n\t\t\tobj.m_re[i] = rre[i] - iim[i];\n\t\t\tobj.m_im[i] = rim[i] + ire[i];\n\t\t\tobj.m_re[m_N - i] = rre[i] + iim[i];\n\t\t\tobj.m_im[m_N - i] = -rim[i] + ire[i];\n\t\t}\n\t}\n\n\treturn obj;\n};\n\nmodule.exports = FFT;"],"sourceRoot":""}