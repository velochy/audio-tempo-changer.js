{"version":3,"sources":["webpack://PhaseVocoder/webpack/universalModuleDefinition","webpack://PhaseVocoder/PhaseVocoder.min.js","webpack://PhaseVocoder/webpack/bootstrap","webpack://PhaseVocoder/./src/vector_helper.js","webpack://PhaseVocoder/./src/phase_vocoder.js","webpack://PhaseVocoder/./src/fft.js"],"names":["window","modules","__webpack_require__","moduleId","installedModules","exports","module","i","l","call","m","c","d","__webpack_require__.d","name","getter","o","Object","defineProperty","enumerable","get","r","__webpack_require__.r","Symbol","toStringTag","value","t","__webpack_require__.t","mode","__esModule","ns","create","key","bind","n","__webpack_require__.n","getDefault","getModuleExports","__webpack_require__.o","object","property","prototype","hasOwnProperty","p","s","VH","float_array","len","Float32Array","blit","src","spos","dest","dpos","set","subarray","FFT","PhaseVocoder","opts","pshift_rigid","frame_ind","re","im","p_re","p_im","ratio","CUR","PREV","prev_mags","b_mags","prev_np","b_npeaks","prpeaks","b_peaks","prev_in_angs","b_in_angs","prev_peak_adeltas","b_peak_adeltas","mags","length","peaks","max","thresh","MAX_PEAK_RATIO","n_peaks","prev_pi","f_delta","MAX_PEAK_JUMP","ppos","cur_np","cur_in_angs","cur_peak_adeltas","ci","pci","interpolate_phase","pi","cpi","Math","abs","round","MATCH_MAG_THRESH","in_angle","pred","PI","windowSize","pk","ana_len","pang","delta","ang","peaks_re","cos","peaks_im","sin","cp","cnp","cre","cim","nim","ind","floor","sgn","atan2","wsizeLog","chosen_tempo","tempo","pow","fft","max_step_len","in_buffer","out_buffer","syn_len","win","hWS","re1","im1","re2","im2","pre2","pim2","qWS","push","f_ind","prev_out_len","syn_drift","syn_drift_per_step","gain_comp","obj","k","tempo_ratio","sum","GAIN_DEAMPLIFY","time","ar","single_step_per_call","inbuffer_contains","unused_in_outbuf","outbuf","tail_end_calls","ceil","filler","outp","opos","outn","oi","left_over","out_len","n_needed","in_len","sdelta","m_re","m_im","inplace","unpack","repack","oblen","gc","ceiling","logN","m_N","m_logN","m_invN","m_revTgt","Array","x","y","twiddleRe","twiddleIm","wIndexStep","stage","wAngleInc","obj.inplace","inverse","numFlies","span","spacing","wMulRe","wMulIm","start","iTop","iBot","wRe","wIm","flyCount","xTopRe","xTopIm","xBotRe","xBotIm","tRe","i1","revI","buf","m_N2","obj.unpack","rre","rim","ire","iim","obj.repack","factory","define","amd","root"],"mappings":"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","file":"PhaseVocoder.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"PhaseVocoder\"] = factory();\n\telse\n\t\troot[\"PhaseVocoder\"] = factory();\n})(window, function() {\nreturn ","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"PhaseVocoder\"] = factory();\n\telse\n\t\troot[\"PhaseVocoder\"] = factory();\n})(window, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// define __esModule on exports\n/******/ \t__webpack_require__.r = function(exports) {\n/******/ \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n/******/ \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n/******/ \t\t}\n/******/ \t\tObject.defineProperty(exports, '__esModule', { value: true });\n/******/ \t};\n/******/\n/******/ \t// create a fake namespace object\n/******/ \t// mode & 1: value is a module id, require it\n/******/ \t// mode & 2: merge all properties of value into the ns\n/******/ \t// mode & 4: return value when already ns object\n/******/ \t// mode & 8|1: behave like require\n/******/ \t__webpack_require__.t = function(value, mode) {\n/******/ \t\tif(mode & 1) value = __webpack_require__(value);\n/******/ \t\tif(mode & 8) return value;\n/******/ \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n/******/ \t\tvar ns = Object.create(null);\n/******/ \t\t__webpack_require__.r(ns);\n/******/ \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n/******/ \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n/******/ \t\treturn ns;\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 1);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports) {\n\n\n// Define an allocator and blit function for float arrays\n// Can be used to achieve backwards compatibility down to dark ages pre IE 10 if needed\n// Also reduces code size a little with closure.\n\nvar VH = { \n\tfloat_array: function(len) { return new Float32Array(len); },\n\tblit: function(src, spos, dest, dpos, len) { dest.set(src.subarray(spos,spos+len),dpos); }\n};\n\n// Pre-IE10 versions:\n/*VH.prototype.float_array = function(len) { return new Array(len); }\nVH.prototype.blit = function(src, spos, dest, dpos, len) { for(var i=0;i<len;i++) dest[dpos+i] = src[spos+i]; };*/\n\nmodule.exports = VH;\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\n(function() {\n\n\t/*\n\t * Phase Vocoder for changing tempo of audio without affecting pitch\n\t * Originally cross-compiled from HaXe\n\t *\n\t * Copyright (c) 2015-2019 Margus Niitsoo\n\t */\n\n\tvar VH = __webpack_require__(0);\n\tvar FFT = __webpack_require__(2);\n\n\tvar PhaseVocoder = function(opts) {\n\n\t\t/**************************\n\t\t* Fill in sensible defaults\n\t\t**************************/\n\n\t\topts = opts || {};\n\t\tvar sampleRate = opts.sampleRate || 44100;\n\t\tvar wsizeLog = opts.wsizeLog || 12; // 4096\n\t\tvar chosen_tempo = opts.tempo || 1.0;\n\n\t\t/**************************\n\t\t* Initialize variables\n\t\t**************************/\n\n\t\t// Some constants\n\t\tvar GAIN_DEAMPLIFY = 0.9; // Slightly lower the volume to avoid volume overflow-compression\n\t\tvar MAX_PEAK_RATIO = 1e-8; // Do not find peaks below this level: 80dB from max\n\t\tvar MAX_PEAK_JUMP = (Math.pow(2.0,50/1200.0)-1.0); // Rel distance (in freq) to look for matches\n\t\tvar MATCH_MAG_THRESH = 0.1; // New if mag_prev < MATCH_MAG_THRESH * mag_new\n\t\t\n\t\tvar windowSize = 1 << wsizeLog;\n\t\tvar fft = FFT(wsizeLog);\n\n\t\t// Caluclate max step size for both ana and syn windows\n\t\t// Has to be < 1/4 of window length or audible artifacts occur\n\t\tvar max_step_len = 1 << (wsizeLog - 2); // 1/4 of window_size\n\t\tmax_step_len -= max_step_len % 100; // Change to a multiple of 100 as tempo is often changed in percents\n\n\t\t//console.log(\"MAX STEP\",max_step_len,windowSize);\n\t\tvar in_buffer = VH.float_array(windowSize + max_step_len + 5);\n\t\tvar out_buffer = VH.float_array(windowSize + max_step_len + 5);\n\t\tvar ana_len = max_step_len, syn_len = max_step_len;\n\n\t\t// Hanning window\n\t\tvar win = VH.float_array(windowSize);\n\t\tfor(var i=0;i<windowSize;i++)\n\t\t\twin[i] = 0.5 * (1 - Math.cos(2 * Math.PI * i / windowSize));\n\n\t\tvar hWS = (windowSize >> 1) + 1;\n\t\tvar re1 = VH.float_array(hWS), im1 = VH.float_array(hWS);\n\t\tvar re2 = VH.float_array(hWS), im2 = VH.float_array(hWS);\n\t\tvar pre2 = VH.float_array(hWS), pim2 = VH.float_array(hWS);\n\n\t\tvar qWS = (hWS >> 1) + 1;\n\t\tvar b_npeaks = [0,0], b_peaks = [], b_in_angs = [], b_peak_adeltas = [];\n\t\tvar b_mags = [];\n\t\tfor(var i=0;i<2;i++) { // Double buffering\n\t\t\tb_peaks.push(VH.float_array(qWS));\n\t\t\tb_in_angs.push(VH.float_array(qWS));\n\t\t\tb_peak_adeltas.push(VH.float_array(qWS));\n\t\t\tb_mags.push(VH.float_array(hWS));\n\t\t}\n\t\t\n\t\tvar peaks_re = VH.float_array(qWS), peaks_im = VH.float_array(qWS);\n\n\t\tvar f_ind = 0, prev_out_len = 0;\n\t\tvar syn_drift = 0.0, syn_drift_per_step = 0.0;\n\t\tvar gain_comp = 1.0;\n\n\t\t// Small utility function to calculate gain compensation\n\t\tvar compute_gain_comp = function(win,syn_len) {\n\t\t\tvar n = win.length / syn_len | 0, sum = 0.0;\n\t\t\tfor(var i=0;i<n;i++) sum += win[i * syn_len];\n\t\t\treturn GAIN_DEAMPLIFY / sum;\n\t\t};\n\n\t\tvar obj = { };\n\t\tobj['flush'] = function() {\n\t\t\tf_ind = 0;\tprev_out_len = 0;\n\t\t\tsyn_drift = 0.0; b_npeaks = [0,0];\n\n\t\t\tfor(var i=0;i<2;i++)\n\t\t\t\tfor(var k=0;k<hWS;k++)\n\t\t\t\t\tb_mags[i][k] = 0.0;\n\n\t\t\tfor(var i=0;i<in_buffer.length;i++) in_buffer[i] = 0.0;\n\t\t\tfor(var i=0;i<out_buffer.length;i++) out_buffer[i] = 0.0;\n\t\t};\n\n\t\t\n\t\tobj['getTempo'] = function() { return chosen_tempo; };\n\t\tobj['setTempo'] = function(tempo_ratio) {\n\t\t\tana_len = syn_len = max_step_len;\n\t\t\tif(tempo_ratio >= 1.0) {\n\t\t\t\tsyn_len = Math.round(ana_len / tempo_ratio);\n\t\t\t} else {\n\t\t\t\tana_len = Math.round(syn_len * tempo_ratio);\n\t\t\t}\n\t\t\tsyn_drift_per_step = (1.0 / tempo_ratio - 1.0 * syn_len / ana_len) * ana_len;\n\t\t\tgain_comp = compute_gain_comp(win,syn_len);\n\t\t\tchosen_tempo = tempo_ratio;\n\t\t\t//console.log(\"TEMPO CHANGE\",tempo_ratio,\"LENS\",ana_len,syn_len,\"GAIN\",gain_comp);\n\t\t};\n\n\t\tobj['flush'](); obj['setTempo'](chosen_tempo);\n\n\n\t\t// Should map time in output samples to that of input\n\t\tobj['mapOutputToInputTime'] = function(time) {\n\t\t\t// TODO\n\t\t\treturn time;\n\t\t};\n\n\t\t/**************************\n\t\t* Small utility functions\n\t\t**************************/\n\t\t\n\t\t// Estimate the phase at (fractional) fft bin ind\n\t\tvar interpolate_phase = function(re,im,ind) {\n\t\t\tvar i = Math.floor(ind);\n\t\t\tvar sgn = i % 2 == 1 ? -1.0 : 1.0;\n\t\t\treturn Math.atan2(sgn * (im[i] - im[i + 1]),sgn * (re[i] - re[i + 1]));\n\t\t};\n\n\t\t// Get ang between -PI and PI\n\t\tvar unwrap = function(ang) {\n\t\t\treturn ang - 2 * Math.PI * Math.round(ang / (2 * Math.PI) );\n\t\t};\n\n\t\t// Try to estimate the phase change if window lengths differ by ratio\n\t\tvar estimate_phase_change = function(ang,k,pang,pk,ratio) {\n\t\t\tvar pred = 2 * Math.PI / windowSize * 0.5 * (pk + k) * ana_len;\n\t\t\tvar ywang = unwrap(ang - pang - pred);\n\n\t\t\treturn (ywang + pred) * ratio;\n\t\t};\n\n\t\t/**************************\n\t\t* Find peaks of spectrum\n\t\t**************************/\n\n\t\tvar find_rpeaks = function(mags,res) {\n\n\t\t\tvar max = 0; for(var i=0;i<mags.length;i++) if (mags[i]>max) max=mags[i];\n\t\t\tvar thresh = MAX_PEAK_RATIO * max;\n\n\t\t\tvar n_peaks = 1, prev_pi = 1; res[0] = 1.0;\n\t\t\tfor(var i=2;i<mags.length;i++) {\n\t\t\t\tvar f_delta = i * MAX_PEAK_JUMP;\n\t\t\t\tif(mags[i]>thresh && mags[i] > mags[i - 1] && mags[i] >= mags[i + 1]) { // Is local peak\n\n\t\t\t\t\t// Use quadratic interpolation to fine-tune the peak location\n\t\t\t\t\tvar ppos = i + (mags[i - 1] - mags[i + 1]) / (2 * (mags[i - 1] - 2 * mags[i] + mags[i + 1]));\n\n\t\t\t\t\t// If far enough from previous peak, add to list\n\t\t\t\t\tif(ppos - res[n_peaks - 1] > f_delta) { res[n_peaks++] = ppos; prev_pi = i; }\n\t\t\t\t\t// Else, if not far enough, but higher than previous, just replace prev \n\t\t\t\t\telse if(mags[i] > mags[prev_pi]) { res[n_peaks - 1] = ppos;\tprev_pi = i; }\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn n_peaks;\n\t\t};\n\n\t\t/**************************\n\t\t* Rigid phase shift\n\t\t**************************/\n\n\t\tvar pshift_rigid = function(frame_ind,re,im,p_re,p_im,ratio) {\n\t\t\tvar CUR = frame_ind % 2, PREV = 1 - CUR;\n\n\t\t\tvar prev_mags = b_mags[PREV];\n\n\t\t\tvar prev_np = b_npeaks[PREV], prpeaks = b_peaks[PREV];\n\t\t\tvar prev_in_angs = b_in_angs[PREV], prev_peak_adeltas = b_peak_adeltas[PREV];\n\n\t\t\t// Calc new mags\n\t\t\tvar mags = b_mags[CUR];\n\t\t\tfor(var i=1;i<mags.length;i++) mags[i] = re[i] * re[i] + im[i] * im[i];\n\t\t\n\t\t\t// Find new peaks\n\t\t\tvar peaks = b_peaks[CUR];\n\t\t\tvar cur_np = b_npeaks[CUR] = find_rpeaks(mags,peaks);\n\n\t\t\t// Start adjusting angles\n\t\t\tvar cur_in_angs = b_in_angs[CUR], cur_peak_adeltas = b_peak_adeltas[CUR];\n\n\t\t\tif(frame_ind == 0 || cur_np == 0) { // If first frame (or no peaks)\n\n\t\t\t\t// Set out_ang = in_ang for all peaks\n\t\t\t\tfor(var ci=0;ci<cur_np;ci++) {\n\t\t\t\t\tvar pci = peaks[ci];\n\t\t\t\t\tprev_in_angs[ci] = prev_peak_adeltas[ci] = interpolate_phase(re,im,pci);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t    /*********************************************************\n\t    \t* Match old peaks with new ones\n\t    \t* Also find where pmag*mag is max for next step\n\t    \t*********************************************************/\n\n\t\t\tvar pi = 0;\n\t\t\tfor(var ci=0;ci<cur_np;ci++) {\n\t\t\t\tvar pci = peaks[ci];\n\n\t\t\t\t// Scroll so peaks[ci] is between prpeaks[pi] and prpeaks[pi+1]\n\t\t\t\twhile(peaks[ci] > prpeaks[pi] && pi != prev_np) ++pi;\n\n\t\t\t\tvar cpi = pi;\n\t\t\t\tif(pi > 0 && pci - prpeaks[pi - 1] < prpeaks[pi] - pci) cpi = pi - 1;\n\n\t\t\t\tvar peak_delta = pci * MAX_PEAK_JUMP;\n\t\t\t\tif(Math.abs(prpeaks[cpi] - pci) < peak_delta && \n\t\t\t\t\tprev_mags[Math.round(prpeaks[cpi])] > \n\t\t\t\t\t\tMATCH_MAG_THRESH * mags[Math.round(pci)]) {\n\n\t\t\t\t\t// Found a matching peak in previous frame, so predict based on the diff\n\t\t\t\t\tvar in_angle = interpolate_phase(re,im,pci);\n\t\t\t\t\tvar out_angle = prev_in_angs[cpi] + prev_peak_adeltas[cpi] +\n\t\t\t\t\t\t\testimate_phase_change(in_angle,pci,prev_in_angs[cpi],prpeaks[cpi],ratio);\n\n\t\t\t\t\tvar delta = out_angle - in_angle;\n\t\t\t\t\tcur_in_angs[ci] = in_angle; cur_peak_adeltas[ci] = delta;\n\t\t\t\t\tpeaks_re[ci] = Math.cos(delta);\tpeaks_im[ci] = Math.sin(delta);\n\t\t\t\t} else { // Not matched - use the same phase as input\n\t\t\t\t\tcur_in_angs[ci] = interpolate_phase(re,im,pci);\n\t\t\t\t\tcur_peak_adeltas[ci] = 0; peaks_re[ci] = 1.0;\tpeaks_im[ci] = 0.0;\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\n\t\t    /********************************************************\n\t\t    * Adjust phase of all bins based on closest peak\n\t\t    *********************************************************/\n\n\t\t    // Add a \"dummy\" peak at the end of array\n\t\t\tpeaks[cur_np] = 2 * windowSize;\n\t\t\t\n\t\t\tvar cpi = 0, cp = peaks[cpi], cnp = peaks[cpi + 1];\n\t\t\tvar cre = peaks_re[cpi], cim = peaks_im[cpi];\n\n\t\t\tfor(var i=1;i<re.length-1;i++) {\n\t\t\t\tif(i >= cp && i - cp > cnp - i) {\n\t\t\t\t\t++cpi; cp = peaks[cpi];\tcnp = peaks[cpi + 1];\n\t\t\t\t\tcre = peaks_re[cpi]; cim = peaks_im[cpi];\n\t\t\t\t}\n\n\t\t\t\tvar nre = re[i] * cre - im[i] * cim;\n\t\t\t\tvar nim = re[i] * cim + im[i] * cre;\n\t\t\t\tre[i] = nre; im[i] = nim;\n\t\t\t}\n\t\t}\n\n\t\t/***********************************\n\t\t* Perform two syn/ana steps \n\t\t*\t(using the two-for-one fft trick)\n\t  \t* Takes windowSize + ana_len samples from in_buffer\n\t  \t*   and shifts in_buffer back by 2*ana_len\n\t  \t* Outputs <retval> samples to out_buffer\n\t\t***********************************/\n\n\t\tvar two_steps = function() {\n\n\t\t\t// To better match the given ratio,\n\t    \t// occasionally tweak syn_len by 1\n\t\t\tsyn_drift += 2 * syn_drift_per_step;\n\t\t\tvar sdelta = syn_drift | 0;\n\t\t\tsyn_drift -= sdelta;\n\t\t\t\n\t\t\t// Pack two steps into fft object\n\t\t\tfor(var i=0;i<windowSize;i++) {\n\t\t\t\tfft.m_re[i] = win[i] * in_buffer[i];\n\t\t\t\tfft.m_im[i] = win[i] * in_buffer[ana_len + i];\n\t\t\t}\n\n\t\t\t// Shift in_buffer back by 2*ana_len\n\t\t\tVH.blit(in_buffer,2*ana_len,\n\t            in_buffer,0,windowSize-ana_len);\n\n\t\t\t// Run the fft\n\t\t\tfft.inplace(false);\n\t\t\tfft.unpack(re1,im1,re2,im2);\n\n\t\t\t// Step 1 - move by syn_len\n\t\t\tvar ratio1 = 1.0 * syn_len / ana_len;\n\t\t\tpshift_rigid(f_ind,re1,im1,pre2,pim2,ratio1);\n\n\t\t\t// Step 2 - move by syn_len+sdelta\n\t\t\tvar ratio2 = 1.0 * (syn_len + sdelta) / ana_len;\n\t\t\tpshift_rigid(f_ind + 1,re2,im2,re1,im1,ratio2);\n\n\t\t\t// Save (modified) re and im\n\t\t\tVH.blit(re2,0,pre2,0,hWS); VH.blit(im2,0,pim2,0,hWS);\n\n\t\t\t// Run ifft\n\t\t\tfft.repack(re1,im1,re2,im2);\n\t\t\tfft.inplace(true);\n\n\t\t\t// Shift out_buffer back by previous out_len;\n\t\t\tvar oblen = out_buffer.length;\n\t\t\tVH.blit(out_buffer,prev_out_len,\n\t            out_buffer,0,oblen-prev_out_len);\n\t\t\t\n\t\t\t// And shift in zeros at the end\n\t\t\tfor(var i=oblen-prev_out_len;i<oblen;i++) out_buffer[i] = 0.0;\n\t\t\t\n\t\t\t// Value overflow protection - scale the packet if max above a threshold\n\t\t    // The distortion this creates is insignificant compared to phase issues\n\t\t\tvar max = 0.0, gc = gain_comp;\n\t\t\tfor(var i=0;i<syn_len;i++)\n\t\t\t\tif(Math.abs(2 * fft.m_re[i]) > max)\n\t\t\t\t\tmax = Math.abs(2 * fft.m_re[i]);\n\t\t\tfor(var i=0;i<windowSize-syn_len;i++)\n\t\t\t\tif(Math.abs(fft.m_re[i + syn_len + sdelta] + fft.m_im[i]) > max)\n\t\t\t\t\tmax = Math.abs(fft.m_re[i + syn_len + sdelta] + fft.m_im[i]);\n\n\t\t\tfor(var i=windowSize-syn_len;i<windowSize;i++)\n\t\t\t\tif(Math.abs(2 * fft.m_im[i]) > max)\n\t\t\t\t\tmax = Math.abs(2 * fft.m_im[i]);\n\n\t\t\t// Find allowed ceiling of a two-step sum and lower gain if needed\n\t\t\tvar ceiling = 1.0 / Math.floor(1.0 * windowSize / (2 * syn_len));\n\t\t\tif(gc * max > ceiling) {\n\t\t\t\t//console.log(\"Gain overflow, lowering volume: \",ceiling / max,gc,max);\n\t\t\t\tgc = ceiling / max;\n\t\t\t}\n\n\t\t\t// Write results to out_buffer\n\t\t\tfor(var i=0;i<windowSize;i++) {\n\t\t\t\tout_buffer[i] += gc * fft.m_re[i];\n\t\t\t\tout_buffer[i + syn_len + sdelta] += gc * fft.m_im[i];\n\t\t\t}\n\n\t\t\tf_ind += 2;\tprev_out_len = 2 * syn_len + sdelta;\n\n\t\t\treturn prev_out_len;\n\t\t}\n\n\t\t// input: array of channels, each a float_array with unbounded amount of samples\n\t\t// output: same format\n\t\tobj['process'] = function(ar) {\n\t\t\t// TODO!!\n\t\t\treturn ar;\n\t\t};\n\n\t\tobj['stretch_filter'] = function(single_step_per_call) {\n\t\t\tvar inbuffer_contains = 0, unused_in_outbuf = 0;\n\t\t\tvar outbuf = VH.float_array(2 * max_step_len + 5);\n\n\t\t\tvar tail_end_calls = Math.ceil((windowSize - ana_len) / (2 * ana_len));\n\n\t\t\treturn function(filler) {\n\t\t\t\treturn function(outp,opos,outn) {\n\n\t\t\t\t\t// It constantly slightly overfills, so samples keep building up\n\t      \t\t\t// This is used to occasionally release the steam\n\t\t\t\t\tif(unused_in_outbuf >= outn) {\n\t\t\t\t\t\tVH.blit(outbuf,0,outp,opos,outn);\n\t\t\t\t\t\tVH.blit(outbuf,outn,outbuf,0,unused_in_outbuf);\n\t\t\t\t\t\treturn outn;\n\t\t\t\t\t}\n\n\t\t\t\t\tVH.blit(outbuf,0,outp,opos,unused_in_outbuf); // Copy full values to output\n\t\t\t\t\tvar oi = unused_in_outbuf;\n\t\t\t\t\t\n\t\t\t\t\tvar left_over = 0, out_len = 0;\n\t\t\t\t\twhile(true) {\n\n\t\t\t\t\t\t// Fetch new input samples\n\t\t\t\t\t\tvar n_needed = windowSize + ana_len - inbuffer_contains;\n\t\t\t\t\t\tif(n_needed >= 0) {\n\t\t\t\t\t\t\tvar in_len = filler(in_buffer,inbuffer_contains,n_needed);\n\t\t\t\t\t\t\tif(in_len < n_needed) {\n\t\t\t\t\t\t\t\tif(tail_end_calls == 0) break;\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\tfor(var i=in_len-ana_len;i<ana_len;i++)\n\t\t\t\t\t\t\t\t\t\tin_buffer[windowSize + i] = 0.0;\n\t\t\t\t\t\t\t\t\ttail_end_calls -= 1;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tinbuffer_contains = windowSize - ana_len;\n\t\t\t\t\t\t} else inbuffer_contains -= 2 * ana_len;\n\n\t\t\t\t\t\t// Run the vocoder\n\t\t\t\t\t\tout_len = two_steps();\n\n\t\t\t\t\t\t// Calculate how many samples are left over (usually 0)\n\t\t\t\t\t\tleft_over = oi + out_len - outn; if(left_over < 0) left_over = 0;\n\n\t\t\t\t\t\t// Copy fully ready samples out\n\t\t\t\t        VH.blit(out_buffer,0,outp,opos+oi,out_len-left_over);\n\n\t\t\t\t\t\toi += out_len;\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(left_over > 0 || single_step_per_call) break;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Copy left over samples to outbuf\n\t      \t\t\tVH.blit(out_buffer,out_len-left_over,outbuf,0,left_over);\n\t      \t\t\tunused_in_outbuf = left_over;\n\n\t\t\t\t\treturn oi;\n\t\t\t\t};\n\t\t\t};\n\t\t}\n\n\t\treturn obj;\n\t};\n\n\t/** @export */\n\tmodule.exports = PhaseVocoder;\n})();\n\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n/*\n * Performs an in-place complex FFT.\n * Adapted from FFT for ActionScript 3 written by Gerald T. Beauregard \n * (original ActionScript3 version, http://gerrybeauregard.wordpress.com/2010/08/03/an-even-faster-as3-fft/)\n *\n * Copyright (c) 2015-2019 Margus Niitsoo\n */\n\nvar VH = __webpack_require__(0);\n\nvar FFT = function(logN) {\n\n\t// Size of the buffer\n\tvar m_N = 1 << logN;\n\n\n\tvar obj = {\n\t\tm_logN : logN, m_N : m_N,\n\t\tm_invN : 1.0 / m_N,\n\t\tm_re : VH.float_array(m_N),\n\t\tm_im : VH.float_array(m_N),\n\t\tm_revTgt : new Array(m_N)\n\t}\n\n\t// Calculate bit reversals\n\tfor(var k = 0; k<m_N; k++) {\n\t\tvar x = k, y = 0;\n\t\tfor(var i=0;i<logN;i++) {\n\t\t\ty <<= 1;\n\t\t\ty |= x & 1;\n\t\t\tx >>= 1;\n\t\t}\n\t\tobj.m_revTgt[k] = y;\n\t}\n\n    // Compute a multiplier factor for the \"twiddle factors\".\n    // The twiddle factors are complex unit vectors spaced at\n    // regular angular intervals. The angle by which the twiddle\n    // factor advances depends on the FFT stage. In many FFT\n    // implementations the twiddle factors are cached.\n\n\tobj.twiddleRe = VH.float_array(obj.m_logN);\n\tobj.twiddleIm = VH.float_array(obj.m_logN);\n\n\tvar wIndexStep = 1;\n\tfor(var stage = 0; stage<obj.m_logN; stage++) {\n\t\tvar wAngleInc = 2.0 * wIndexStep * Math.PI * obj.m_invN;\n\t\tobj.twiddleRe[stage] = Math.cos(wAngleInc);\n\t\tobj.twiddleIm[stage] = Math.sin(wAngleInc);\n\t\twIndexStep <<= 1;\n\t}\n\n\t// In-place FFT function\n\tobj.inplace = function(inverse) {\n\n\t\tvar m_re = obj.m_re, m_im = obj.m_im;\n\t\tvar m_N = obj.m_N, m_logN = obj.m_logN;\n\n\t\tvar numFlies = m_N >> 1;\n\t\tvar span = m_N >> 1;\n\t\tvar spacing = m_N;\n\n\t\tif(inverse) {\n\t\t\tvar m_invN = 1.0/m_N;\n\t\t\tfor(var i=0; i<m_N; i++) {\n\t\t\t\tm_re[i] *= m_invN;\n\t\t\t\tm_im[i] *= m_invN;\n\t\t\t}\n\t\t}\n\n\t\t// For each stage of the FFT\n\t\tfor(var stage=0; stage<m_logN; stage++) {\n\t\t\tvar wMulRe = obj.twiddleRe[stage];\n\t\t\tvar wMulIm = obj.twiddleIm[stage];\n\t\t\tif(!inverse) wMulIm *= -1;\n\n\t\t\tvar start = 0;\n\t\t\twhile(start < m_N) {\n\t\t\t\tvar iTop = start, iBot = start + span;\n\t\t\t\tvar wRe = 1.0, wIm = 0.0;\n\n\t\t\t\t// For each butterfly in this stage\n\t\t\t\tfor(var flyCount=0; flyCount<numFlies; flyCount++) {\n\t\t\t\t\t// Get the top & bottom values\n\t\t\t\t\tvar xTopRe = m_re[iTop];\n\t\t\t\t\tvar xTopIm = m_im[iTop];\n\t\t\t\t\tvar xBotRe = m_re[iBot];\n\t\t\t\t\tvar xBotIm = m_im[iBot];\n\n\t\t\t\t\t// Top branch of butterfly has addition\n\t\t\t\t\tm_re[iTop] = xTopRe + xBotRe;\n\t\t\t\t\tm_im[iTop] = xTopIm + xBotIm;\n\n\t\t\t\t\t// Bottom branch of butterly has subtraction,\n                    // followed by multiplication by twiddle factor\n\t\t\t\t\txBotRe = xTopRe - xBotRe;\n\t\t\t\t\txBotIm = xTopIm - xBotIm;\n\n\t\t\t\t\tm_re[iBot] = xBotRe * wRe - xBotIm * wIm;\n\t\t\t\t\tm_im[iBot] = xBotRe * wIm + xBotIm * wRe;\n\n\t\t\t\t\t// Advance butterfly to next top & bottom positions\n                    iTop++;\n                    iBot++;\n\n                    // Update the twiddle factor, via complex multiply\n                    // by unit vector with the appropriate angle\n                    // (wRe + j wIm) = (wRe + j wIm) x (wMulRe + j wMulIm)\n\t\t\t\t\tvar tRe = wRe;\n\t\t\t\t\twRe = wRe * wMulRe - wIm * wMulIm;\n\t\t\t\t\twIm = tRe * wMulIm + wIm * wMulRe;\n\t\t\t\t}\n\t\t\t\tstart += spacing;\n\t\t\t}\n\t\t\tnumFlies >>= 1;\n\t\t\tspan >>= 1;\n\t\t\tspacing >>= 1;\n\t\t}\n\n\t\tvar revI, buf, m_revTgt = obj.m_revTgt;\n\t\tfor(var i1=0; i1<m_N; i1++)\n\t\t\tif(m_revTgt[i1] > i1) {\n                // Bit-Reversal is an involution i.e.\n                // x.revTgt.revTgt==x\n                // So switching values around\n                // restores the original order\n\t\t\t\trevI = m_revTgt[i1];\n\t\t\t\tbuf = m_re[revI];\n\t\t\t\tm_re[revI] = m_re[i1];\n\t\t\t\tm_re[i1] = buf;\n\t\t\t\tbuf = m_im[revI];\n\t\t\t\tm_im[revI] = m_im[i1];\n\t\t\t\tm_im[i1] = buf;\n\t\t\t}\n\t}\n\n\tvar m_N2 = m_N >> 1; // m_N/2 needed in un/repack below\n\n\t// Two-for-one trick for real-valued FFT:\n\t// Put one series in re, other in im, run \"inplace\",\n\t// then call this \"unpack\" function\n\tobj.unpack = function(rre,rim,ire,iim) {\n\t\trre[0] = obj.m_re[0]; ire[0] = obj.m_im[0];\n\t\trim[0] = iim[0] = 0;\n\t\trre[m_N2] = obj.m_re[m_N2];\n\t\tire[m_N2] = obj.m_im[m_N2];\n\t\trim[m_N2] = iim[m_N2] = 0;\n\t\tfor(var i = 1;i<m_N2;i++) {\n\t\t\trre[i] = (obj.m_re[i] + obj.m_re[m_N - i]) / 2;\n\t\t\trim[i] = (obj.m_im[i] - obj.m_im[m_N - i]) / 2;\n\t\t\tire[i] = (obj.m_im[i] + obj.m_im[m_N - i]) / 2;\n\t\t\tiim[i] = (-obj.m_re[i] + obj.m_re[m_N - i]) / 2;\n\t\t}\n\t}\n\t\n\t// The two-for-one trick if you know results are real-valued\n\t// Call \"repack\", then fft.inplace(true) and you have\n\t// First fft in re and second in im\n\tobj.repack = function(rre,rim,ire,iim) {\n\t\tobj.m_re[0] = rre[0]; obj.m_im[0] = ire[0];\n\t\tobj.m_re[m_N2] = rre[m_N2]; obj.m_im[m_N2] = ire[m_N2];\n\t\tfor(var i = 1;i<m_N2;i++) {\n\t\t\tobj.m_re[i] = rre[i] - iim[i];\n\t\t\tobj.m_im[i] = rim[i] + ire[i];\n\t\t\tobj.m_re[m_N - i] = rre[i] + iim[i];\n\t\t\tobj.m_im[m_N - i] = -rim[i] + ire[i];\n\t\t}\n\t}\n\n\treturn obj;\n};\n\nmodule.exports = FFT;\n\n/***/ })\n/******/ ]);\n});"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 1);\n","\n// Define an allocator and blit function for float arrays\n// Can be used to achieve backwards compatibility down to dark ages pre IE 10 if needed\n// Also reduces code size a little with closure.\n\nvar VH = { \n\tfloat_array: function(len) { return new Float32Array(len); },\n\tblit: function(src, spos, dest, dpos, len) { dest.set(src.subarray(spos,spos+len),dpos); }\n};\n\n// Pre-IE10 versions:\n/*VH.prototype.float_array = function(len) { return new Array(len); }\nVH.prototype.blit = function(src, spos, dest, dpos, len) { for(var i=0;i<len;i++) dest[dpos+i] = src[spos+i]; };*/\n\nmodule.exports = VH;","(function() {\n\n\t/*\n\t * Phase Vocoder for changing tempo of audio without affecting pitch\n\t * Originally cross-compiled from HaXe\n\t *\n\t * Copyright (c) 2015-2019 Margus Niitsoo\n\t */\n\n\tvar VH = require('./vector_helper.js');\n\tvar FFT = require('./fft.js');\n\n\tvar PhaseVocoder = function(opts) {\n\n\t\t/**************************\n\t\t* Fill in sensible defaults\n\t\t**************************/\n\n\t\topts = opts || {};\n\t\tvar sampleRate = opts.sampleRate || 44100;\n\t\tvar wsizeLog = opts.wsizeLog || 12; // 4096\n\t\tvar chosen_tempo = opts.tempo || 1.0;\n\n\t\t/**************************\n\t\t* Initialize variables\n\t\t**************************/\n\n\t\t// Some constants\n\t\tvar GAIN_DEAMPLIFY = 0.9; // Slightly lower the volume to avoid volume overflow-compression\n\t\tvar MAX_PEAK_RATIO = 1e-8; // Do not find peaks below this level: 80dB from max\n\t\tvar MAX_PEAK_JUMP = (Math.pow(2.0,50/1200.0)-1.0); // Rel distance (in freq) to look for matches\n\t\tvar MATCH_MAG_THRESH = 0.1; // New if mag_prev < MATCH_MAG_THRESH * mag_new\n\t\t\n\t\tvar windowSize = 1 << wsizeLog;\n\t\tvar fft = FFT(wsizeLog);\n\n\t\t// Caluclate max step size for both ana and syn windows\n\t\t// Has to be < 1/4 of window length or audible artifacts occur\n\t\tvar max_step_len = 1 << (wsizeLog - 2); // 1/4 of window_size\n\t\tmax_step_len -= max_step_len % 100; // Change to a multiple of 100 as tempo is often changed in percents\n\n\t\t//console.log(\"MAX STEP\",max_step_len,windowSize);\n\t\tvar in_buffer = VH.float_array(windowSize + max_step_len + 5);\n\t\tvar out_buffer = VH.float_array(windowSize + max_step_len + 5);\n\t\tvar ana_len = max_step_len, syn_len = max_step_len;\n\n\t\t// Hanning window\n\t\tvar win = VH.float_array(windowSize);\n\t\tfor(var i=0;i<windowSize;i++)\n\t\t\twin[i] = 0.5 * (1 - Math.cos(2 * Math.PI * i / windowSize));\n\n\t\tvar hWS = (windowSize >> 1) + 1;\n\t\tvar re1 = VH.float_array(hWS), im1 = VH.float_array(hWS);\n\t\tvar re2 = VH.float_array(hWS), im2 = VH.float_array(hWS);\n\t\tvar pre2 = VH.float_array(hWS), pim2 = VH.float_array(hWS);\n\n\t\tvar qWS = (hWS >> 1) + 1;\n\t\tvar b_npeaks = [0,0], b_peaks = [], b_in_angs = [], b_peak_adeltas = [];\n\t\tvar b_mags = [];\n\t\tfor(var i=0;i<2;i++) { // Double buffering\n\t\t\tb_peaks.push(VH.float_array(qWS));\n\t\t\tb_in_angs.push(VH.float_array(qWS));\n\t\t\tb_peak_adeltas.push(VH.float_array(qWS));\n\t\t\tb_mags.push(VH.float_array(hWS));\n\t\t}\n\t\t\n\t\tvar peaks_re = VH.float_array(qWS), peaks_im = VH.float_array(qWS);\n\n\t\tvar f_ind = 0, prev_out_len = 0;\n\t\tvar syn_drift = 0.0, syn_drift_per_step = 0.0;\n\t\tvar gain_comp = 1.0;\n\n\t\t// Small utility function to calculate gain compensation\n\t\tvar compute_gain_comp = function(win,syn_len) {\n\t\t\tvar n = win.length / syn_len | 0, sum = 0.0;\n\t\t\tfor(var i=0;i<n;i++) sum += win[i * syn_len];\n\t\t\treturn GAIN_DEAMPLIFY / sum;\n\t\t};\n\n\t\tvar obj = { };\n\t\tobj['flush'] = function() {\n\t\t\tf_ind = 0;\tprev_out_len = 0;\n\t\t\tsyn_drift = 0.0; b_npeaks = [0,0];\n\n\t\t\tfor(var i=0;i<2;i++)\n\t\t\t\tfor(var k=0;k<hWS;k++)\n\t\t\t\t\tb_mags[i][k] = 0.0;\n\n\t\t\tfor(var i=0;i<in_buffer.length;i++) in_buffer[i] = 0.0;\n\t\t\tfor(var i=0;i<out_buffer.length;i++) out_buffer[i] = 0.0;\n\t\t};\n\n\t\t\n\t\tobj['getTempo'] = function() { return chosen_tempo; };\n\t\tobj['setTempo'] = function(tempo_ratio) {\n\t\t\tana_len = syn_len = max_step_len;\n\t\t\tif(tempo_ratio >= 1.0) {\n\t\t\t\tsyn_len = Math.round(ana_len / tempo_ratio);\n\t\t\t} else {\n\t\t\t\tana_len = Math.round(syn_len * tempo_ratio);\n\t\t\t}\n\t\t\tsyn_drift_per_step = (1.0 / tempo_ratio - 1.0 * syn_len / ana_len) * ana_len;\n\t\t\tgain_comp = compute_gain_comp(win,syn_len);\n\t\t\tchosen_tempo = tempo_ratio;\n\t\t\t//console.log(\"TEMPO CHANGE\",tempo_ratio,\"LENS\",ana_len,syn_len,\"GAIN\",gain_comp);\n\t\t};\n\n\t\tobj['flush'](); obj['setTempo'](chosen_tempo);\n\n\n\t\t// Should map time in output samples to that of input\n\t\tobj['mapOutputToInputTime'] = function(time) {\n\t\t\t// TODO\n\t\t\treturn time;\n\t\t};\n\n\t\t/**************************\n\t\t* Small utility functions\n\t\t**************************/\n\t\t\n\t\t// Estimate the phase at (fractional) fft bin ind\n\t\tvar interpolate_phase = function(re,im,ind) {\n\t\t\tvar i = Math.floor(ind);\n\t\t\tvar sgn = i % 2 == 1 ? -1.0 : 1.0;\n\t\t\treturn Math.atan2(sgn * (im[i] - im[i + 1]),sgn * (re[i] - re[i + 1]));\n\t\t};\n\n\t\t// Get ang between -PI and PI\n\t\tvar unwrap = function(ang) {\n\t\t\treturn ang - 2 * Math.PI * Math.round(ang / (2 * Math.PI) );\n\t\t};\n\n\t\t// Try to estimate the phase change if window lengths differ by ratio\n\t\tvar estimate_phase_change = function(ang,k,pang,pk,ratio) {\n\t\t\tvar pred = 2 * Math.PI / windowSize * 0.5 * (pk + k) * ana_len;\n\t\t\tvar ywang = unwrap(ang - pang - pred);\n\n\t\t\treturn (ywang + pred) * ratio;\n\t\t};\n\n\t\t/**************************\n\t\t* Find peaks of spectrum\n\t\t**************************/\n\n\t\tvar find_rpeaks = function(mags,res) {\n\n\t\t\tvar max = 0; for(var i=0;i<mags.length;i++) if (mags[i]>max) max=mags[i];\n\t\t\tvar thresh = MAX_PEAK_RATIO * max;\n\n\t\t\tvar n_peaks = 1, prev_pi = 1; res[0] = 1.0;\n\t\t\tfor(var i=2;i<mags.length;i++) {\n\t\t\t\tvar f_delta = i * MAX_PEAK_JUMP;\n\t\t\t\tif(mags[i]>thresh && mags[i] > mags[i - 1] && mags[i] >= mags[i + 1]) { // Is local peak\n\n\t\t\t\t\t// Use quadratic interpolation to fine-tune the peak location\n\t\t\t\t\tvar ppos = i + (mags[i - 1] - mags[i + 1]) / (2 * (mags[i - 1] - 2 * mags[i] + mags[i + 1]));\n\n\t\t\t\t\t// If far enough from previous peak, add to list\n\t\t\t\t\tif(ppos - res[n_peaks - 1] > f_delta) { res[n_peaks++] = ppos; prev_pi = i; }\n\t\t\t\t\t// Else, if not far enough, but higher than previous, just replace prev \n\t\t\t\t\telse if(mags[i] > mags[prev_pi]) { res[n_peaks - 1] = ppos;\tprev_pi = i; }\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn n_peaks;\n\t\t};\n\n\t\t/**************************\n\t\t* Rigid phase shift\n\t\t**************************/\n\n\t\tvar pshift_rigid = function(frame_ind,re,im,p_re,p_im,ratio) {\n\t\t\tvar CUR = frame_ind % 2, PREV = 1 - CUR;\n\n\t\t\tvar prev_mags = b_mags[PREV];\n\n\t\t\tvar prev_np = b_npeaks[PREV], prpeaks = b_peaks[PREV];\n\t\t\tvar prev_in_angs = b_in_angs[PREV], prev_peak_adeltas = b_peak_adeltas[PREV];\n\n\t\t\t// Calc new mags\n\t\t\tvar mags = b_mags[CUR];\n\t\t\tfor(var i=1;i<mags.length;i++) mags[i] = re[i] * re[i] + im[i] * im[i];\n\t\t\n\t\t\t// Find new peaks\n\t\t\tvar peaks = b_peaks[CUR];\n\t\t\tvar cur_np = b_npeaks[CUR] = find_rpeaks(mags,peaks);\n\n\t\t\t// Start adjusting angles\n\t\t\tvar cur_in_angs = b_in_angs[CUR], cur_peak_adeltas = b_peak_adeltas[CUR];\n\n\t\t\tif(frame_ind == 0 || cur_np == 0) { // If first frame (or no peaks)\n\n\t\t\t\t// Set out_ang = in_ang for all peaks\n\t\t\t\tfor(var ci=0;ci<cur_np;ci++) {\n\t\t\t\t\tvar pci = peaks[ci];\n\t\t\t\t\tprev_in_angs[ci] = prev_peak_adeltas[ci] = interpolate_phase(re,im,pci);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t    /*********************************************************\n\t    \t* Match old peaks with new ones\n\t    \t* Also find where pmag*mag is max for next step\n\t    \t*********************************************************/\n\n\t\t\tvar pi = 0;\n\t\t\tfor(var ci=0;ci<cur_np;ci++) {\n\t\t\t\tvar pci = peaks[ci];\n\n\t\t\t\t// Scroll so peaks[ci] is between prpeaks[pi] and prpeaks[pi+1]\n\t\t\t\twhile(peaks[ci] > prpeaks[pi] && pi != prev_np) ++pi;\n\n\t\t\t\tvar cpi = pi;\n\t\t\t\tif(pi > 0 && pci - prpeaks[pi - 1] < prpeaks[pi] - pci) cpi = pi - 1;\n\n\t\t\t\tvar peak_delta = pci * MAX_PEAK_JUMP;\n\t\t\t\tif(Math.abs(prpeaks[cpi] - pci) < peak_delta && \n\t\t\t\t\tprev_mags[Math.round(prpeaks[cpi])] > \n\t\t\t\t\t\tMATCH_MAG_THRESH * mags[Math.round(pci)]) {\n\n\t\t\t\t\t// Found a matching peak in previous frame, so predict based on the diff\n\t\t\t\t\tvar in_angle = interpolate_phase(re,im,pci);\n\t\t\t\t\tvar out_angle = prev_in_angs[cpi] + prev_peak_adeltas[cpi] +\n\t\t\t\t\t\t\testimate_phase_change(in_angle,pci,prev_in_angs[cpi],prpeaks[cpi],ratio);\n\n\t\t\t\t\tvar delta = out_angle - in_angle;\n\t\t\t\t\tcur_in_angs[ci] = in_angle; cur_peak_adeltas[ci] = delta;\n\t\t\t\t\tpeaks_re[ci] = Math.cos(delta);\tpeaks_im[ci] = Math.sin(delta);\n\t\t\t\t} else { // Not matched - use the same phase as input\n\t\t\t\t\tcur_in_angs[ci] = interpolate_phase(re,im,pci);\n\t\t\t\t\tcur_peak_adeltas[ci] = 0; peaks_re[ci] = 1.0;\tpeaks_im[ci] = 0.0;\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\n\t\t    /********************************************************\n\t\t    * Adjust phase of all bins based on closest peak\n\t\t    *********************************************************/\n\n\t\t    // Add a \"dummy\" peak at the end of array\n\t\t\tpeaks[cur_np] = 2 * windowSize;\n\t\t\t\n\t\t\tvar cpi = 0, cp = peaks[cpi], cnp = peaks[cpi + 1];\n\t\t\tvar cre = peaks_re[cpi], cim = peaks_im[cpi];\n\n\t\t\tfor(var i=1;i<re.length-1;i++) {\n\t\t\t\tif(i >= cp && i - cp > cnp - i) {\n\t\t\t\t\t++cpi; cp = peaks[cpi];\tcnp = peaks[cpi + 1];\n\t\t\t\t\tcre = peaks_re[cpi]; cim = peaks_im[cpi];\n\t\t\t\t}\n\n\t\t\t\tvar nre = re[i] * cre - im[i] * cim;\n\t\t\t\tvar nim = re[i] * cim + im[i] * cre;\n\t\t\t\tre[i] = nre; im[i] = nim;\n\t\t\t}\n\t\t}\n\n\t\t/***********************************\n\t\t* Perform two syn/ana steps \n\t\t*\t(using the two-for-one fft trick)\n\t  \t* Takes windowSize + ana_len samples from in_buffer\n\t  \t*   and shifts in_buffer back by 2*ana_len\n\t  \t* Outputs <retval> samples to out_buffer\n\t\t***********************************/\n\n\t\tvar two_steps = function() {\n\n\t\t\t// To better match the given ratio,\n\t    \t// occasionally tweak syn_len by 1\n\t\t\tsyn_drift += 2 * syn_drift_per_step;\n\t\t\tvar sdelta = syn_drift | 0;\n\t\t\tsyn_drift -= sdelta;\n\t\t\t\n\t\t\t// Pack two steps into fft object\n\t\t\tfor(var i=0;i<windowSize;i++) {\n\t\t\t\tfft.m_re[i] = win[i] * in_buffer[i];\n\t\t\t\tfft.m_im[i] = win[i] * in_buffer[ana_len + i];\n\t\t\t}\n\n\t\t\t// Shift in_buffer back by 2*ana_len\n\t\t\tVH.blit(in_buffer,2*ana_len,\n\t            in_buffer,0,windowSize-ana_len);\n\n\t\t\t// Run the fft\n\t\t\tfft.inplace(false);\n\t\t\tfft.unpack(re1,im1,re2,im2);\n\n\t\t\t// Step 1 - move by syn_len\n\t\t\tvar ratio1 = 1.0 * syn_len / ana_len;\n\t\t\tpshift_rigid(f_ind,re1,im1,pre2,pim2,ratio1);\n\n\t\t\t// Step 2 - move by syn_len+sdelta\n\t\t\tvar ratio2 = 1.0 * (syn_len + sdelta) / ana_len;\n\t\t\tpshift_rigid(f_ind + 1,re2,im2,re1,im1,ratio2);\n\n\t\t\t// Save (modified) re and im\n\t\t\tVH.blit(re2,0,pre2,0,hWS); VH.blit(im2,0,pim2,0,hWS);\n\n\t\t\t// Run ifft\n\t\t\tfft.repack(re1,im1,re2,im2);\n\t\t\tfft.inplace(true);\n\n\t\t\t// Shift out_buffer back by previous out_len;\n\t\t\tvar oblen = out_buffer.length;\n\t\t\tVH.blit(out_buffer,prev_out_len,\n\t            out_buffer,0,oblen-prev_out_len);\n\t\t\t\n\t\t\t// And shift in zeros at the end\n\t\t\tfor(var i=oblen-prev_out_len;i<oblen;i++) out_buffer[i] = 0.0;\n\t\t\t\n\t\t\t// Value overflow protection - scale the packet if max above a threshold\n\t\t    // The distortion this creates is insignificant compared to phase issues\n\t\t\tvar max = 0.0, gc = gain_comp;\n\t\t\tfor(var i=0;i<syn_len;i++)\n\t\t\t\tif(Math.abs(2 * fft.m_re[i]) > max)\n\t\t\t\t\tmax = Math.abs(2 * fft.m_re[i]);\n\t\t\tfor(var i=0;i<windowSize-syn_len;i++)\n\t\t\t\tif(Math.abs(fft.m_re[i + syn_len + sdelta] + fft.m_im[i]) > max)\n\t\t\t\t\tmax = Math.abs(fft.m_re[i + syn_len + sdelta] + fft.m_im[i]);\n\n\t\t\tfor(var i=windowSize-syn_len;i<windowSize;i++)\n\t\t\t\tif(Math.abs(2 * fft.m_im[i]) > max)\n\t\t\t\t\tmax = Math.abs(2 * fft.m_im[i]);\n\n\t\t\t// Find allowed ceiling of a two-step sum and lower gain if needed\n\t\t\tvar ceiling = 1.0 / Math.floor(1.0 * windowSize / (2 * syn_len));\n\t\t\tif(gc * max > ceiling) {\n\t\t\t\t//console.log(\"Gain overflow, lowering volume: \",ceiling / max,gc,max);\n\t\t\t\tgc = ceiling / max;\n\t\t\t}\n\n\t\t\t// Write results to out_buffer\n\t\t\tfor(var i=0;i<windowSize;i++) {\n\t\t\t\tout_buffer[i] += gc * fft.m_re[i];\n\t\t\t\tout_buffer[i + syn_len + sdelta] += gc * fft.m_im[i];\n\t\t\t}\n\n\t\t\tf_ind += 2;\tprev_out_len = 2 * syn_len + sdelta;\n\n\t\t\treturn prev_out_len;\n\t\t}\n\n\t\t// input: array of channels, each a float_array with unbounded amount of samples\n\t\t// output: same format\n\t\tobj['process'] = function(ar) {\n\t\t\t// TODO!!\n\t\t\treturn ar;\n\t\t};\n\n\t\tobj['stretch_filter'] = function(single_step_per_call) {\n\t\t\tvar inbuffer_contains = 0, unused_in_outbuf = 0;\n\t\t\tvar outbuf = VH.float_array(2 * max_step_len + 5);\n\n\t\t\tvar tail_end_calls = Math.ceil((windowSize - ana_len) / (2 * ana_len));\n\n\t\t\treturn function(filler) {\n\t\t\t\treturn function(outp,opos,outn) {\n\n\t\t\t\t\t// It constantly slightly overfills, so samples keep building up\n\t      \t\t\t// This is used to occasionally release the steam\n\t\t\t\t\tif(unused_in_outbuf >= outn) {\n\t\t\t\t\t\tVH.blit(outbuf,0,outp,opos,outn);\n\t\t\t\t\t\tVH.blit(outbuf,outn,outbuf,0,unused_in_outbuf);\n\t\t\t\t\t\treturn outn;\n\t\t\t\t\t}\n\n\t\t\t\t\tVH.blit(outbuf,0,outp,opos,unused_in_outbuf); // Copy full values to output\n\t\t\t\t\tvar oi = unused_in_outbuf;\n\t\t\t\t\t\n\t\t\t\t\tvar left_over = 0, out_len = 0;\n\t\t\t\t\twhile(true) {\n\n\t\t\t\t\t\t// Fetch new input samples\n\t\t\t\t\t\tvar n_needed = windowSize + ana_len - inbuffer_contains;\n\t\t\t\t\t\tif(n_needed >= 0) {\n\t\t\t\t\t\t\tvar in_len = filler(in_buffer,inbuffer_contains,n_needed);\n\t\t\t\t\t\t\tif(in_len < n_needed) {\n\t\t\t\t\t\t\t\tif(tail_end_calls == 0) break;\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\tfor(var i=in_len-ana_len;i<ana_len;i++)\n\t\t\t\t\t\t\t\t\t\tin_buffer[windowSize + i] = 0.0;\n\t\t\t\t\t\t\t\t\ttail_end_calls -= 1;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tinbuffer_contains = windowSize - ana_len;\n\t\t\t\t\t\t} else inbuffer_contains -= 2 * ana_len;\n\n\t\t\t\t\t\t// Run the vocoder\n\t\t\t\t\t\tout_len = two_steps();\n\n\t\t\t\t\t\t// Calculate how many samples are left over (usually 0)\n\t\t\t\t\t\tleft_over = oi + out_len - outn; if(left_over < 0) left_over = 0;\n\n\t\t\t\t\t\t// Copy fully ready samples out\n\t\t\t\t        VH.blit(out_buffer,0,outp,opos+oi,out_len-left_over);\n\n\t\t\t\t\t\toi += out_len;\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(left_over > 0 || single_step_per_call) break;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Copy left over samples to outbuf\n\t      \t\t\tVH.blit(out_buffer,out_len-left_over,outbuf,0,left_over);\n\t      \t\t\tunused_in_outbuf = left_over;\n\n\t\t\t\t\treturn oi;\n\t\t\t\t};\n\t\t\t};\n\t\t}\n\n\t\treturn obj;\n\t};\n\n\t/** @export */\n\tmodule.exports = PhaseVocoder;\n})();\n","'use strict';\n\n/*\n * Performs an in-place complex FFT.\n * Adapted from FFT for ActionScript 3 written by Gerald T. Beauregard \n * (original ActionScript3 version, http://gerrybeauregard.wordpress.com/2010/08/03/an-even-faster-as3-fft/)\n *\n * Copyright (c) 2015-2019 Margus Niitsoo\n */\n\nvar VH = require('./vector_helper.js');\n\nvar FFT = function(logN) {\n\n\t// Size of the buffer\n\tvar m_N = 1 << logN;\n\n\n\tvar obj = {\n\t\tm_logN : logN, m_N : m_N,\n\t\tm_invN : 1.0 / m_N,\n\t\tm_re : VH.float_array(m_N),\n\t\tm_im : VH.float_array(m_N),\n\t\tm_revTgt : new Array(m_N)\n\t}\n\n\t// Calculate bit reversals\n\tfor(var k = 0; k<m_N; k++) {\n\t\tvar x = k, y = 0;\n\t\tfor(var i=0;i<logN;i++) {\n\t\t\ty <<= 1;\n\t\t\ty |= x & 1;\n\t\t\tx >>= 1;\n\t\t}\n\t\tobj.m_revTgt[k] = y;\n\t}\n\n    // Compute a multiplier factor for the \"twiddle factors\".\n    // The twiddle factors are complex unit vectors spaced at\n    // regular angular intervals. The angle by which the twiddle\n    // factor advances depends on the FFT stage. In many FFT\n    // implementations the twiddle factors are cached.\n\n\tobj.twiddleRe = VH.float_array(obj.m_logN);\n\tobj.twiddleIm = VH.float_array(obj.m_logN);\n\n\tvar wIndexStep = 1;\n\tfor(var stage = 0; stage<obj.m_logN; stage++) {\n\t\tvar wAngleInc = 2.0 * wIndexStep * Math.PI * obj.m_invN;\n\t\tobj.twiddleRe[stage] = Math.cos(wAngleInc);\n\t\tobj.twiddleIm[stage] = Math.sin(wAngleInc);\n\t\twIndexStep <<= 1;\n\t}\n\n\t// In-place FFT function\n\tobj.inplace = function(inverse) {\n\n\t\tvar m_re = obj.m_re, m_im = obj.m_im;\n\t\tvar m_N = obj.m_N, m_logN = obj.m_logN;\n\n\t\tvar numFlies = m_N >> 1;\n\t\tvar span = m_N >> 1;\n\t\tvar spacing = m_N;\n\n\t\tif(inverse) {\n\t\t\tvar m_invN = 1.0/m_N;\n\t\t\tfor(var i=0; i<m_N; i++) {\n\t\t\t\tm_re[i] *= m_invN;\n\t\t\t\tm_im[i] *= m_invN;\n\t\t\t}\n\t\t}\n\n\t\t// For each stage of the FFT\n\t\tfor(var stage=0; stage<m_logN; stage++) {\n\t\t\tvar wMulRe = obj.twiddleRe[stage];\n\t\t\tvar wMulIm = obj.twiddleIm[stage];\n\t\t\tif(!inverse) wMulIm *= -1;\n\n\t\t\tvar start = 0;\n\t\t\twhile(start < m_N) {\n\t\t\t\tvar iTop = start, iBot = start + span;\n\t\t\t\tvar wRe = 1.0, wIm = 0.0;\n\n\t\t\t\t// For each butterfly in this stage\n\t\t\t\tfor(var flyCount=0; flyCount<numFlies; flyCount++) {\n\t\t\t\t\t// Get the top & bottom values\n\t\t\t\t\tvar xTopRe = m_re[iTop];\n\t\t\t\t\tvar xTopIm = m_im[iTop];\n\t\t\t\t\tvar xBotRe = m_re[iBot];\n\t\t\t\t\tvar xBotIm = m_im[iBot];\n\n\t\t\t\t\t// Top branch of butterfly has addition\n\t\t\t\t\tm_re[iTop] = xTopRe + xBotRe;\n\t\t\t\t\tm_im[iTop] = xTopIm + xBotIm;\n\n\t\t\t\t\t// Bottom branch of butterly has subtraction,\n                    // followed by multiplication by twiddle factor\n\t\t\t\t\txBotRe = xTopRe - xBotRe;\n\t\t\t\t\txBotIm = xTopIm - xBotIm;\n\n\t\t\t\t\tm_re[iBot] = xBotRe * wRe - xBotIm * wIm;\n\t\t\t\t\tm_im[iBot] = xBotRe * wIm + xBotIm * wRe;\n\n\t\t\t\t\t// Advance butterfly to next top & bottom positions\n                    iTop++;\n                    iBot++;\n\n                    // Update the twiddle factor, via complex multiply\n                    // by unit vector with the appropriate angle\n                    // (wRe + j wIm) = (wRe + j wIm) x (wMulRe + j wMulIm)\n\t\t\t\t\tvar tRe = wRe;\n\t\t\t\t\twRe = wRe * wMulRe - wIm * wMulIm;\n\t\t\t\t\twIm = tRe * wMulIm + wIm * wMulRe;\n\t\t\t\t}\n\t\t\t\tstart += spacing;\n\t\t\t}\n\t\t\tnumFlies >>= 1;\n\t\t\tspan >>= 1;\n\t\t\tspacing >>= 1;\n\t\t}\n\n\t\tvar revI, buf, m_revTgt = obj.m_revTgt;\n\t\tfor(var i1=0; i1<m_N; i1++)\n\t\t\tif(m_revTgt[i1] > i1) {\n                // Bit-Reversal is an involution i.e.\n                // x.revTgt.revTgt==x\n                // So switching values around\n                // restores the original order\n\t\t\t\trevI = m_revTgt[i1];\n\t\t\t\tbuf = m_re[revI];\n\t\t\t\tm_re[revI] = m_re[i1];\n\t\t\t\tm_re[i1] = buf;\n\t\t\t\tbuf = m_im[revI];\n\t\t\t\tm_im[revI] = m_im[i1];\n\t\t\t\tm_im[i1] = buf;\n\t\t\t}\n\t}\n\n\tvar m_N2 = m_N >> 1; // m_N/2 needed in un/repack below\n\n\t// Two-for-one trick for real-valued FFT:\n\t// Put one series in re, other in im, run \"inplace\",\n\t// then call this \"unpack\" function\n\tobj.unpack = function(rre,rim,ire,iim) {\n\t\trre[0] = obj.m_re[0]; ire[0] = obj.m_im[0];\n\t\trim[0] = iim[0] = 0;\n\t\trre[m_N2] = obj.m_re[m_N2];\n\t\tire[m_N2] = obj.m_im[m_N2];\n\t\trim[m_N2] = iim[m_N2] = 0;\n\t\tfor(var i = 1;i<m_N2;i++) {\n\t\t\trre[i] = (obj.m_re[i] + obj.m_re[m_N - i]) / 2;\n\t\t\trim[i] = (obj.m_im[i] - obj.m_im[m_N - i]) / 2;\n\t\t\tire[i] = (obj.m_im[i] + obj.m_im[m_N - i]) / 2;\n\t\t\tiim[i] = (-obj.m_re[i] + obj.m_re[m_N - i]) / 2;\n\t\t}\n\t}\n\t\n\t// The two-for-one trick if you know results are real-valued\n\t// Call \"repack\", then fft.inplace(true) and you have\n\t// First fft in re and second in im\n\tobj.repack = function(rre,rim,ire,iim) {\n\t\tobj.m_re[0] = rre[0]; obj.m_im[0] = ire[0];\n\t\tobj.m_re[m_N2] = rre[m_N2]; obj.m_im[m_N2] = ire[m_N2];\n\t\tfor(var i = 1;i<m_N2;i++) {\n\t\t\tobj.m_re[i] = rre[i] - iim[i];\n\t\t\tobj.m_im[i] = rim[i] + ire[i];\n\t\t\tobj.m_re[m_N - i] = rre[i] + iim[i];\n\t\t\tobj.m_im[m_N - i] = -rim[i] + ire[i];\n\t\t}\n\t}\n\n\treturn obj;\n};\n\nmodule.exports = FFT;"],"sourceRoot":""}