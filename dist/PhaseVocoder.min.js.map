{"version":3,"sources":["webpack://PhaseVocoder/webpack/universalModuleDefinition","webpack://PhaseVocoder/PhaseVocoder.min.js","webpack://PhaseVocoder/webpack/bootstrap","webpack://PhaseVocoder/./src/vector_helper.js","webpack://PhaseVocoder/./src/phase_vocoder.js","webpack://PhaseVocoder/./src/fft.js"],"names":["window","modules","__webpack_require__","moduleId","installedModules","exports","module","i","l","call","m","c","d","__webpack_require__.d","name","getter","o","Object","defineProperty","enumerable","get","r","__webpack_require__.r","Symbol","toStringTag","value","t","__webpack_require__.t","mode","__esModule","ns","create","key","bind","n","__webpack_require__.n","getDefault","getModuleExports","__webpack_require__.o","object","property","prototype","hasOwnProperty","p","s","VH","float_array","len","Float32Array","blit","src","spos","dest","dpos","set","subarray","FFT","PhaseVocoder","opts","pshift_rigid","frame_ind","re","im","p_re","p_im","ratio","CUR","PREV","prev_mags","b_mags","prev_np","b_npeaks","prpeaks","b_peaks","prev_in_angs","b_in_angs","prev_peak_adeltas","b_peak_adeltas","mags","length","peaks","max","thresh","MAX_PEAK_RATIO","n_peaks","prev_pi","f_delta","MAX_PEAK_JUMP","ppos","cur_np","cur_in_angs","cur_peak_adeltas","ci","pci","interpolate_phase","pi","cpi","Math","abs","round","MATCH_MAG_THRESH","in_angle","pred","PI","windowSize","pk","ana_len","pang","delta","ang","peaks_re","cos","peaks_im","sin","cp","cnp","cre","cim","nim","ind","floor","sgn","atan2","sampleRate","wsizeLog","chosen_tempo","tempo","pow","fft","max_step_len","in_buffer","out_buffer","syn_len","win","hWS","re1","im1","re2","im2","pre2","pim2","qWS","push","in_time","out_time","changes","f_ind","prev_out_len","gain_comp","syn_drift","syn_drift_per_step","obj","given_out_time","cc","discard_output_seconds","k","pop","tempo_ratio","sum","GAIN_DEAMPLIFY","lc","inbuffer_contains","unused_in_outbuf","in_ar","mix","in_len","mult","n_steps","out_len","outp","ii","oi","left_over","res_len","n_needed","sdelta","m_re","m_im","inplace","unpack","repack","oblen","gc","ceiling","out_ar","logN","m_N","m_logN","m_invN","m_revTgt","Array","x","y","twiddleRe","twiddleIm","wIndexStep","stage","wAngleInc","obj.inplace","inverse","numFlies","span","spacing","wMulRe","wMulIm","start","iTop","iBot","wRe","wIm","flyCount","xTopRe","xTopIm","xBotRe","xBotIm","tRe","i1","revI","buf","m_N2","obj.unpack","rre","rim","ire","iim","obj.repack","factory","define","amd","root"],"mappings":"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","file":"PhaseVocoder.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"PhaseVocoder\"] = factory();\n\telse\n\t\troot[\"PhaseVocoder\"] = factory();\n})(window, function() {\nreturn ","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"PhaseVocoder\"] = factory();\n\telse\n\t\troot[\"PhaseVocoder\"] = factory();\n})(window, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// define __esModule on exports\n/******/ \t__webpack_require__.r = function(exports) {\n/******/ \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n/******/ \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n/******/ \t\t}\n/******/ \t\tObject.defineProperty(exports, '__esModule', { value: true });\n/******/ \t};\n/******/\n/******/ \t// create a fake namespace object\n/******/ \t// mode & 1: value is a module id, require it\n/******/ \t// mode & 2: merge all properties of value into the ns\n/******/ \t// mode & 4: return value when already ns object\n/******/ \t// mode & 8|1: behave like require\n/******/ \t__webpack_require__.t = function(value, mode) {\n/******/ \t\tif(mode & 1) value = __webpack_require__(value);\n/******/ \t\tif(mode & 8) return value;\n/******/ \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n/******/ \t\tvar ns = Object.create(null);\n/******/ \t\t__webpack_require__.r(ns);\n/******/ \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n/******/ \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n/******/ \t\treturn ns;\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 1);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports) {\n\n\n// Define an allocator and blit function for float arrays\n// Can be used to achieve backwards compatibility down to dark ages pre IE 10 if needed\n// Also reduces code size a little with closure.\n\nvar VH = { \n\tfloat_array: function(len) { return new Float32Array(len); },\n\tblit: function(src, spos, dest, dpos, len) { dest.set(src.subarray(spos,spos+len),dpos); }\n};\n\n// Pre-IE10 versions:\n/*VH.prototype.float_array = function(len) { return new Array(len); }\nVH.prototype.blit = function(src, spos, dest, dpos, len) { for(var i=0;i<len;i++) dest[dpos+i] = src[spos+i]; };*/\n\nmodule.exports = VH;\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\n(function() {\n\n\t/*\n\t * Phase Vocoder for changing tempo of audio without affecting pitch\n\t * Originally cross-compiled from HaXe\n\t *\n\t * Copyright (c) 2015-2019 Margus Niitsoo\n\t */\n\n\tvar VH = __webpack_require__(0);\n\tvar FFT = __webpack_require__(2);\n\n\tvar PhaseVocoder = function(opts) {\n\n\t\t/**************************\n\t\t* Fill in sensible defaults\n\t\t**************************/\n\n\t\topts = opts || {};\n\t\tvar sampleRate = opts.sampleRate || 44100;\n\t\tvar wsizeLog = opts.wsizeLog || 12; // 4096\n\t\tvar chosen_tempo = opts.tempo || 1.0;\n\t\tvar numChannels = opts.numChannels || 2;\n\n\t\t/**************************\n\t\t* Initialize variables\n\t\t**************************/\n\n\t\t// Some constants\n\t\tvar GAIN_DEAMPLIFY = 0.9; // Slightly lower the volume to avoid volume overflow-compression\n\t\tvar MAX_PEAK_RATIO = 1e-8; // Do not find peaks below this level: 80dB from max\n\t\tvar MAX_PEAK_JUMP = (Math.pow(2.0,50/1200.0)-1.0); // Rel distance (in freq) to look for matches\n\t\tvar MATCH_MAG_THRESH = 0.1; // New if mag_prev < MATCH_MAG_THRESH * mag_new\n\t\t\n\t\tvar windowSize = 1 << wsizeLog;\n\t\tvar fft = FFT(wsizeLog);\n\n\t\t// Caluclate max step size for both ana and syn windows\n\t\t// Has to be < 1/4 of window length or audible artifacts occur\n\t\tvar max_step_len = 1 << (wsizeLog - 2); // 1/4 of window_size\n\t\tmax_step_len -= max_step_len % 100; // Change to a multiple of 100 as tempo is often changed in percents\n\n\t\t//console.log(\"MAX STEP\",max_step_len,windowSize);\n\t\tvar in_buffer = VH.float_array(windowSize + max_step_len + 5);\n\t\tvar out_buffer = VH.float_array(windowSize + max_step_len + 5);\n\t\tvar ana_len = max_step_len, syn_len = max_step_len;\n\n\t\t// Hanning window\n\t\tvar win = VH.float_array(windowSize);\n\t\tfor(var i=0;i<windowSize;i++)\n\t\t\twin[i] = 0.5 * (1 - Math.cos(2 * Math.PI * i / windowSize));\n\n\t\tvar hWS = (windowSize >> 1) + 1;\n\t\tvar re1 = VH.float_array(hWS), im1 = VH.float_array(hWS);\n\t\tvar re2 = VH.float_array(hWS), im2 = VH.float_array(hWS);\n\t\tvar pre2 = VH.float_array(hWS), pim2 = VH.float_array(hWS);\n\n\t\tvar qWS = (hWS >> 1) + 1;\n\t\tvar b_npeaks = [0,0], b_peaks = [], b_in_angs = [], b_peak_adeltas = [];\n\t\tvar b_mags = [];\n\t\tfor(var i=0;i<2;i++) { // Double buffering\n\t\t\tb_peaks.push(VH.float_array(qWS));\n\t\t\tb_in_angs.push(VH.float_array(qWS));\n\t\t\tb_peak_adeltas.push(VH.float_array(qWS));\n\t\t\tb_mags.push(VH.float_array(hWS));\n\t\t}\n\t\t\n\t\tvar peaks_re = VH.float_array(qWS), peaks_im = VH.float_array(qWS);\n\n\t\t// Keep track of time (in samples) in both input and output streams\n\t\tvar in_time = 0.0, out_time = 0.0;\n\n\t\t// Track the changes for mapOutputToInputTime\n\t\tvar changes = [{ in_time: 0.0, out_time: 0.0, tempo: chosen_tempo }];\n\n\t\tvar f_ind = 0, prev_out_len = 0, gain_comp = 1.0;\n\t\tvar syn_drift = 0.0, syn_drift_per_step = 0.0;\n\n\t\tvar obj = { };\n\n\t\t// Should map time in output to time in input\n\t\tobj['mapOutputToInputTime'] = function(given_out_time) {\n\t\t\tvar ci = changes.length-1;\n\t\t\twhile(given_out_time<changes[ci].out_time && ci>0) ci--;\n\t\t\tvar cc = changes[ci];\n\t\t\treturn cc.in_time + cc.tempo*(given_out_time-cc.out_time);\n\t\t};\n\n\t\tobj['flush'] = function(discard_output_seconds) {\n\t\t\tf_ind = 0;\tprev_out_len = 0;\n\t\t\tsyn_drift = 0.0; b_npeaks = [0,0];\n\n\t\t\tfor(var i=0;i<2;i++)\n\t\t\t\tfor(var k=0;k<hWS;k++)\n\t\t\t\t\tb_mags[i][k] = 0.0;\n\n\t\t\tfor(var i=0;i<in_buffer.length;i++) in_buffer[i] = 0.0;\n\t\t\tfor(var i=0;i<out_buffer.length;i++) out_buffer[i] = 0.0;\n\n\t\t\t// Scroll time cursor back by discard_output_seconds\n\t\t\tif (discard_output_seconds) {\n\n\t\t\t\t// Scroll back time in both coordinates\n\t\t\t\tout_time = Math.max(0,out_time-discard_output_seconds);\n\t\t\t\tin_time = obj['mapOutputToInputTime'](out_time);\n\n\t\t\t\t// Clear the now-made-future tempo changes (if any)\n\t\t\t\tvar ci = changes.length-1;\n\t\t\t\twhile(out_time<=changes[ci].out_time && ci>=0) { changes.pop(); ci--; }\n\n\t\t\t\t// Add a tempo change reflecting current state\n\t\t\t\tchanges.push({ \n\t\t\t\t\tin_time: in_time, out_time: out_time,\n\t\t\t\t\ttempo: chosen_tempo\n\t\t\t\t})\n\t\t\t}\n\t\t};\n\n\t\t// Small utility function to calculate gain compensation\n\t\tvar compute_gain_comp = function(win,syn_len) {\n\t\t\tvar n = win.length / syn_len | 0, sum = 0.0;\n\t\t\tfor(var i=0;i<n;i++) sum += win[i * syn_len];\n\t\t\treturn GAIN_DEAMPLIFY / sum;\n\t\t};\n\t\t\n\t\tobj['getTempo'] = function() { return chosen_tempo; };\n\t\tobj['setTempo'] = function(tempo_ratio) {\n\t\t\tana_len = syn_len = max_step_len;\n\t\t\tif(tempo_ratio >= 1.0) {\n\t\t\t\tsyn_len = Math.round(ana_len / tempo_ratio);\n\t\t\t} else {\n\t\t\t\tana_len = Math.round(syn_len * tempo_ratio);\n\t\t\t}\n\t\t\tsyn_drift_per_step = (1.0 / tempo_ratio - 1.0 * syn_len / ana_len) * ana_len;\n\t\t\tgain_comp = compute_gain_comp(win,syn_len);\n\t\t\tchosen_tempo = tempo_ratio;\n\t\t\t//console.log(\"TEMPO CHANGE\",tempo_ratio,\"LENS\",ana_len,syn_len,\"GAIN\",gain_comp);\n\n\t\t\t// Handle book-keeping for time map\n\t\t\tvar lc = changes[changes.length-1];\n\t\t\tif (lc.out_time == out_time) // no samples since last change\n\t\t\t\tlc.tempo = tempo_ratio; // Just replace last change event\n\t\t\telse //add new entry\n\t\t\t\tchanges.push({ \n\t\t\t\t\tin_time: in_time, out_time: out_time,\n\t\t\t\t\ttempo: tempo_ratio\n\t\t\t\t})\n\t\t};\n\n\t\tobj['flush'](0); obj['setTempo'](chosen_tempo);\n\n\n\t\t/**************************\n\t\t* Small utility functions\n\t\t**************************/\n\t\t\n\t\t// Estimate the phase at (fractional) fft bin ind\n\t\tvar interpolate_phase = function(re,im,ind) {\n\t\t\tvar i = Math.floor(ind);\n\t\t\tvar sgn = i % 2 == 1 ? -1.0 : 1.0;\n\t\t\treturn Math.atan2(sgn * (im[i] - im[i + 1]),sgn * (re[i] - re[i + 1]));\n\t\t};\n\n\t\t// Get ang between -PI and PI\n\t\tvar unwrap = function(ang) {\n\t\t\treturn ang - 2 * Math.PI * Math.round(ang / (2 * Math.PI) );\n\t\t};\n\n\t\t// Try to estimate the phase change if window lengths differ by ratio\n\t\tvar estimate_phase_change = function(ang,k,pang,pk,ratio) {\n\t\t\tvar pred = 2 * Math.PI / windowSize * 0.5 * (pk + k) * ana_len;\n\t\t\tvar ywang = unwrap(ang - pang - pred);\n\n\t\t\treturn (ywang + pred) * ratio;\n\t\t};\n\n\t\t/**************************\n\t\t* Find peaks of spectrum\n\t\t**************************/\n\n\t\tvar find_rpeaks = function(mags,res) {\n\n\t\t\tvar max = 0; for(var i=0;i<mags.length;i++) if (mags[i]>max) max=mags[i];\n\t\t\tvar thresh = MAX_PEAK_RATIO * max;\n\n\t\t\tvar n_peaks = 1, prev_pi = 1; res[0] = 1.0;\n\t\t\tfor(var i=2;i<mags.length;i++) {\n\t\t\t\tvar f_delta = i * MAX_PEAK_JUMP;\n\t\t\t\tif(mags[i]>thresh && mags[i] > mags[i - 1] && mags[i] >= mags[i + 1]) { // Is local peak\n\n\t\t\t\t\t// Use quadratic interpolation to fine-tune the peak location\n\t\t\t\t\tvar ppos = i + (mags[i - 1] - mags[i + 1]) / (2 * (mags[i - 1] - 2 * mags[i] + mags[i + 1]));\n\n\t\t\t\t\t// If far enough from previous peak, add to list\n\t\t\t\t\tif(ppos - res[n_peaks - 1] > f_delta) { res[n_peaks++] = ppos; prev_pi = i; }\n\t\t\t\t\t// Else, if not far enough, but higher than previous, just replace prev \n\t\t\t\t\telse if(mags[i] > mags[prev_pi]) { res[n_peaks - 1] = ppos;\tprev_pi = i; }\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn n_peaks;\n\t\t};\n\n\t\t/**************************\n\t\t* Rigid phase shift\n\t\t**************************/\n\n\t\tvar pshift_rigid = function(frame_ind,re,im,p_re,p_im,ratio) {\n\t\t\tvar CUR = frame_ind % 2, PREV = 1 - CUR;\n\n\t\t\tvar prev_mags = b_mags[PREV];\n\n\t\t\tvar prev_np = b_npeaks[PREV], prpeaks = b_peaks[PREV];\n\t\t\tvar prev_in_angs = b_in_angs[PREV], prev_peak_adeltas = b_peak_adeltas[PREV];\n\n\t\t\t// Calc new mags\n\t\t\tvar mags = b_mags[CUR];\n\t\t\tfor(var i=1;i<mags.length;i++) mags[i] = re[i] * re[i] + im[i] * im[i];\n\t\t\n\t\t\t// Find new peaks\n\t\t\tvar peaks = b_peaks[CUR];\n\t\t\tvar cur_np = b_npeaks[CUR] = find_rpeaks(mags,peaks);\n\n\t\t\t// Start adjusting angles\n\t\t\tvar cur_in_angs = b_in_angs[CUR], cur_peak_adeltas = b_peak_adeltas[CUR];\n\n\t\t\tif(frame_ind == 0 || cur_np == 0) { // If first frame (or no peaks)\n\n\t\t\t\t// Set out_ang = in_ang for all peaks\n\t\t\t\tfor(var ci=0;ci<cur_np;ci++) {\n\t\t\t\t\tvar pci = peaks[ci];\n\t\t\t\t\tprev_in_angs[ci] = prev_peak_adeltas[ci] = interpolate_phase(re,im,pci);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t    /*********************************************************\n\t    \t* Match old peaks with new ones\n\t    \t* Also find where pmag*mag is max for next step\n\t    \t*********************************************************/\n\n\t\t\tvar pi = 0;\n\t\t\tfor(var ci=0;ci<cur_np;ci++) {\n\t\t\t\tvar pci = peaks[ci];\n\n\t\t\t\t// Scroll so peaks[ci] is between prpeaks[pi] and prpeaks[pi+1]\n\t\t\t\twhile(peaks[ci] > prpeaks[pi] && pi != prev_np) ++pi;\n\n\t\t\t\tvar cpi = pi;\n\t\t\t\tif(pi > 0 && pci - prpeaks[pi - 1] < prpeaks[pi] - pci) cpi = pi - 1;\n\n\t\t\t\tvar peak_delta = pci * MAX_PEAK_JUMP;\n\t\t\t\tif(Math.abs(prpeaks[cpi] - pci) < peak_delta && \n\t\t\t\t\tprev_mags[Math.round(prpeaks[cpi])] > \n\t\t\t\t\t\tMATCH_MAG_THRESH * mags[Math.round(pci)]) {\n\n\t\t\t\t\t// Found a matching peak in previous frame, so predict based on the diff\n\t\t\t\t\tvar in_angle = interpolate_phase(re,im,pci);\n\t\t\t\t\tvar out_angle = prev_in_angs[cpi] + prev_peak_adeltas[cpi] +\n\t\t\t\t\t\t\testimate_phase_change(in_angle,pci,prev_in_angs[cpi],prpeaks[cpi],ratio);\n\n\t\t\t\t\tvar delta = out_angle - in_angle;\n\t\t\t\t\tcur_in_angs[ci] = in_angle; cur_peak_adeltas[ci] = delta;\n\t\t\t\t\tpeaks_re[ci] = Math.cos(delta);\tpeaks_im[ci] = Math.sin(delta);\n\t\t\t\t} else { // Not matched - use the same phase as input\n\t\t\t\t\tcur_in_angs[ci] = interpolate_phase(re,im,pci);\n\t\t\t\t\tcur_peak_adeltas[ci] = 0; peaks_re[ci] = 1.0;\tpeaks_im[ci] = 0.0;\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\n\t\t    /********************************************************\n\t\t    * Adjust phase of all bins based on closest peak\n\t\t    *********************************************************/\n\n\t\t    // Add a \"dummy\" peak at the end of array\n\t\t\tpeaks[cur_np] = 2 * windowSize;\n\t\t\t\n\t\t\tvar cpi = 0, cp = peaks[cpi], cnp = peaks[cpi + 1];\n\t\t\tvar cre = peaks_re[cpi], cim = peaks_im[cpi];\n\n\t\t\tfor(var i=1;i<re.length-1;i++) {\n\t\t\t\tif(i >= cp && i - cp > cnp - i) {\n\t\t\t\t\t++cpi; cp = peaks[cpi];\tcnp = peaks[cpi + 1];\n\t\t\t\t\tcre = peaks_re[cpi]; cim = peaks_im[cpi];\n\t\t\t\t}\n\n\t\t\t\tvar nre = re[i] * cre - im[i] * cim;\n\t\t\t\tvar nim = re[i] * cim + im[i] * cre;\n\t\t\t\tre[i] = nre; im[i] = nim;\n\t\t\t}\n\t\t}\n\n\t\t/***********************************\n\t\t* Perform two syn/ana steps \n\t\t*\t(using the two-for-one fft trick)\n\t  \t* Takes windowSize + ana_len samples from in_buffer\n\t  \t*   and shifts in_buffer back by 2*ana_len\n\t  \t* Outputs <retval> samples to out_buffer\n\t\t***********************************/\n\n\t\tvar two_steps = function() {\n\n\t\t\t// To better match the given ratio,\n\t    \t// occasionally tweak syn_len by 1 or 2\n\t\t\tsyn_drift += 2 * syn_drift_per_step;\n\t\t\tvar sdelta = syn_drift | 0;\n\t\t\tsyn_drift -= sdelta;\n\t\t\t\n\t\t\t// Pack two steps into fft object\n\t\t\tfor(var i=0;i<windowSize;i++) {\n\t\t\t\tfft.m_re[i] = win[i] * in_buffer[i];\n\t\t\t\tfft.m_im[i] = win[i] * in_buffer[ana_len + i];\n\t\t\t}\n\n\t\t\t// Shift in_buffer back by 2*ana_len\n\t\t\tVH.blit(in_buffer,2*ana_len,\n\t            in_buffer,0,windowSize-ana_len);\n\n\t\t\t// Run the fft\n\t\t\tfft.inplace(false);\n\t\t\tfft.unpack(re1,im1,re2,im2);\n\n\t\t\t// Step 1 - move by syn_len\n\t\t\tvar ratio1 = 1.0 * syn_len / ana_len;\n\t\t\tpshift_rigid(f_ind,re1,im1,pre2,pim2,ratio1);\n\n\t\t\t// Step 2 - move by syn_len+sdelta\n\t\t\tvar ratio2 = 1.0 * (syn_len + sdelta) / ana_len;\n\t\t\tpshift_rigid(f_ind + 1,re2,im2,re1,im1,ratio2);\n\n\t\t\t// Save (modified) re and im\n\t\t\tVH.blit(re2,0,pre2,0,hWS); VH.blit(im2,0,pim2,0,hWS);\n\n\t\t\t// Run ifft\n\t\t\tfft.repack(re1,im1,re2,im2);\n\t\t\tfft.inplace(true);\n\n\t\t\t// Shift out_buffer back by previous out_len;\n\t\t\tvar oblen = out_buffer.length;\n\t\t\tVH.blit(out_buffer,prev_out_len,\n\t            out_buffer,0,oblen-prev_out_len);\n\t\t\t\n\t\t\t// And shift in zeros at the end\n\t\t\tfor(var i=oblen-prev_out_len;i<oblen;i++) out_buffer[i] = 0.0;\n\t\t\t\n\t\t\t// Value overflow protection - scale the packet if max above a threshold\n\t\t    // The distortion this creates is insignificant compared to phase issues\n\t\t\tvar max = 0.0, gc = gain_comp;\n\t\t\tfor(var i=0;i<syn_len;i++)\n\t\t\t\tif(Math.abs(2 * fft.m_re[i]) > max)\n\t\t\t\t\tmax = Math.abs(2 * fft.m_re[i]);\n\t\t\tfor(var i=0;i<windowSize-syn_len;i++)\n\t\t\t\tif(Math.abs(fft.m_re[i + syn_len + sdelta] + fft.m_im[i]) > max)\n\t\t\t\t\tmax = Math.abs(fft.m_re[i + syn_len + sdelta] + fft.m_im[i]);\n\n\t\t\tfor(var i=windowSize-syn_len;i<windowSize;i++)\n\t\t\t\tif(Math.abs(2 * fft.m_im[i]) > max)\n\t\t\t\t\tmax = Math.abs(2 * fft.m_im[i]);\n\n\t\t\t// Find allowed ceiling of a two-step sum and lower gain if needed\n\t\t\tvar ceiling = 1.0 / Math.floor(1.0 * windowSize / (2 * syn_len));\n\t\t\tif(gc * max > ceiling) {\n\t\t\t\t//console.log(\"Gain overflow, lowering volume: \",ceiling / max,gc,max);\n\t\t\t\tgc = ceiling / max;\n\t\t\t}\n\n\t\t\t// Write results to out_buffer\n\t\t\tfor(var i=0;i<windowSize;i++) {\n\t\t\t\tout_buffer[i] += gc * fft.m_re[i];\n\t\t\t\tout_buffer[i + syn_len + sdelta] += gc * fft.m_im[i];\n\t\t\t}\n\n\t\t\tf_ind += 2;\tprev_out_len = 2 * syn_len + sdelta;\n\n\t\t\treturn prev_out_len;\n\t\t}\n\n\t\t// Two variables used for \"process\"\n\t\tvar inbuffer_contains = 0, unused_in_outbuf = 0;\n\n\t\t// input: array of channels, each a float_array with unbounded amount of samples\n\t\t// output: same format\n\t\tobj['process'] = function(in_ar) {\n\n\t\t\t// Mix channels together (if needed)\n\t\t\tvar mix = in_ar[0], in_len = in_ar[0].length; \n\t\t\tif (in_ar.length>1) {\n\t\t\t\tmix = VH.float_array(in_ar[0].length);\n\t\t\t\tvar mult = 1.0/in_ar.length;\n\t\t\t\tfor(var c=0;c<in_ar.length;c++)\n\t\t\t\t\tfor(var i=0;i<in_len;i++)\n\t\t\t\t\t\tmix[i] += mult*in_ar[c][i];\n\t\t\t}\n\n\t\t\t// Calculate output length\n\t\t\t// Should underestimate, and by no more than 4, which can easily fit in the unused_in_outbuf\n\t\t\tvar consumable_samples = inbuffer_contains + in_len - (windowSize - ana_len);\n\t\t\tvar n_steps = 2*Math.floor(Math.max(0,consumable_samples)/(2*ana_len));\n\t\t\tvar out_len = unused_in_outbuf + syn_len*n_steps +\n\t\t\t\t\t\t\tMath.floor(syn_drift+syn_drift_per_step*n_steps);\n\n\t\t\tif (unused_in_outbuf>out_len) out_len = unused_in_outbuf;\n\n\t\t\t// Allocate output\n\t\t\tvar outp = VH.float_array(out_len);\n\n\t\t\t// Copy previously unused but ready values to output\n\t\t\tVH.blit(out_buffer,0,outp,0,unused_in_outbuf); \n\t\t\tvar ii = 0, oi = unused_in_outbuf;\n\t\t\t\n\t\t\tvar left_over = 0, res_len = 0;\n\t\t\twhile(true) {\n\n\t\t\t\t// Calculate how many new samples we need to call two_steps\n\t\t\t\tvar n_needed = windowSize + ana_len - inbuffer_contains;\n\t\t\t\t\n\t\t\t\tif (ii+n_needed>in_len) { // Not enough samples for next step\n\t\t\t\t\t// Copy whats left to inbuffer and break out of the loop\n\t\t\t\t\tVH.blit(mix,ii,in_buffer,inbuffer_contains,in_len-ii);\n\t\t\t\t\tinbuffer_contains += in_len-ii; ii = in_len;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if (n_needed <= 0) // Already enough - can happen if tempo changed\n\t\t\t\t\tinbuffer_contains -= 2 * ana_len; \n\t\t\t\telse { // Main case - we have enough\n\t\t\t\t\t// Copy over this many samples from input\n\t\t\t\t\tVH.blit(mix,ii,in_buffer,inbuffer_contains,n_needed);\n\t\t\t\t\tii += n_needed;\t\t\t\t\t\n\t\t\t\t\tinbuffer_contains = windowSize - ana_len;\n\t\t\t\t}\n\n\t\t\t\t// Invariant: left_over should be 0 here as it should break!\n\n\t\t\t\t// Run the vocoder\n\t\t\t\tres_len = two_steps();\n\n\t\t\t\t// Move time pointers\n\t\t\t\tin_time += 2*ana_len/sampleRate; out_time += res_len/sampleRate;\n\n\t\t\t\t// Calculate how many samples are left over (usually 0)\n\t\t\t\tleft_over = oi + res_len - out_len; if(left_over < 0) left_over = 0;\n\n\t\t\t\t// Copy fully ready samples out\n\t\t        VH.blit(out_buffer,0,outp,oi,res_len-left_over);\n\n\t\t\t\toi += res_len;\n\t\t\t}\n\n\t\t\t// Copy left over samples to the beginning of out_buffer\n  \t\t\tVH.blit(out_buffer,res_len-left_over,out_buffer,0,left_over);\n  \t\t\tunused_in_outbuf = left_over;\n\n  \t\t\t//////////////////////// DONE\n\n\t\t\t// Clone the result to match the number of input channels\n\t\t\tvar out_ar = [];\n\t\t\tfor(var c=0;c<in_ar.length;c++) out_ar.push(outp);\n\n\t\t\treturn out_ar;\n\t\t};\n\n\t\treturn obj;\n\t};\n\n\t/** @export */\n\tmodule.exports = PhaseVocoder;\n})();\n\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n/*\n * Performs an in-place complex FFT.\n * Adapted from FFT for ActionScript 3 written by Gerald T. Beauregard \n * (original ActionScript3 version, http://gerrybeauregard.wordpress.com/2010/08/03/an-even-faster-as3-fft/)\n *\n * Copyright (c) 2015-2019 Margus Niitsoo\n */\n\nvar VH = __webpack_require__(0);\n\nvar FFT = function(logN) {\n\n\t// Size of the buffer\n\tvar m_N = 1 << logN;\n\n\n\tvar obj = {\n\t\tm_logN : logN, m_N : m_N,\n\t\tm_invN : 1.0 / m_N,\n\t\tm_re : VH.float_array(m_N),\n\t\tm_im : VH.float_array(m_N),\n\t\tm_revTgt : new Array(m_N)\n\t}\n\n\t// Calculate bit reversals\n\tfor(var k = 0; k<m_N; k++) {\n\t\tvar x = k, y = 0;\n\t\tfor(var i=0;i<logN;i++) {\n\t\t\ty <<= 1;\n\t\t\ty |= x & 1;\n\t\t\tx >>= 1;\n\t\t}\n\t\tobj.m_revTgt[k] = y;\n\t}\n\n    // Compute a multiplier factor for the \"twiddle factors\".\n    // The twiddle factors are complex unit vectors spaced at\n    // regular angular intervals. The angle by which the twiddle\n    // factor advances depends on the FFT stage. In many FFT\n    // implementations the twiddle factors are cached.\n\n\tobj.twiddleRe = VH.float_array(obj.m_logN);\n\tobj.twiddleIm = VH.float_array(obj.m_logN);\n\n\tvar wIndexStep = 1;\n\tfor(var stage = 0; stage<obj.m_logN; stage++) {\n\t\tvar wAngleInc = 2.0 * wIndexStep * Math.PI * obj.m_invN;\n\t\tobj.twiddleRe[stage] = Math.cos(wAngleInc);\n\t\tobj.twiddleIm[stage] = Math.sin(wAngleInc);\n\t\twIndexStep <<= 1;\n\t}\n\n\t// In-place FFT function\n\tobj.inplace = function(inverse) {\n\n\t\tvar m_re = obj.m_re, m_im = obj.m_im;\n\t\tvar m_N = obj.m_N, m_logN = obj.m_logN;\n\n\t\tvar numFlies = m_N >> 1;\n\t\tvar span = m_N >> 1;\n\t\tvar spacing = m_N;\n\n\t\tif(inverse) {\n\t\t\tvar m_invN = 1.0/m_N;\n\t\t\tfor(var i=0; i<m_N; i++) {\n\t\t\t\tm_re[i] *= m_invN;\n\t\t\t\tm_im[i] *= m_invN;\n\t\t\t}\n\t\t}\n\n\t\t// For each stage of the FFT\n\t\tfor(var stage=0; stage<m_logN; stage++) {\n\t\t\tvar wMulRe = obj.twiddleRe[stage];\n\t\t\tvar wMulIm = obj.twiddleIm[stage];\n\t\t\tif(!inverse) wMulIm *= -1;\n\n\t\t\tvar start = 0;\n\t\t\twhile(start < m_N) {\n\t\t\t\tvar iTop = start, iBot = start + span;\n\t\t\t\tvar wRe = 1.0, wIm = 0.0;\n\n\t\t\t\t// For each butterfly in this stage\n\t\t\t\tfor(var flyCount=0; flyCount<numFlies; flyCount++) {\n\t\t\t\t\t// Get the top & bottom values\n\t\t\t\t\tvar xTopRe = m_re[iTop];\n\t\t\t\t\tvar xTopIm = m_im[iTop];\n\t\t\t\t\tvar xBotRe = m_re[iBot];\n\t\t\t\t\tvar xBotIm = m_im[iBot];\n\n\t\t\t\t\t// Top branch of butterfly has addition\n\t\t\t\t\tm_re[iTop] = xTopRe + xBotRe;\n\t\t\t\t\tm_im[iTop] = xTopIm + xBotIm;\n\n\t\t\t\t\t// Bottom branch of butterly has subtraction,\n                    // followed by multiplication by twiddle factor\n\t\t\t\t\txBotRe = xTopRe - xBotRe;\n\t\t\t\t\txBotIm = xTopIm - xBotIm;\n\n\t\t\t\t\tm_re[iBot] = xBotRe * wRe - xBotIm * wIm;\n\t\t\t\t\tm_im[iBot] = xBotRe * wIm + xBotIm * wRe;\n\n\t\t\t\t\t// Advance butterfly to next top & bottom positions\n                    iTop++;\n                    iBot++;\n\n                    // Update the twiddle factor, via complex multiply\n                    // by unit vector with the appropriate angle\n                    // (wRe + j wIm) = (wRe + j wIm) x (wMulRe + j wMulIm)\n\t\t\t\t\tvar tRe = wRe;\n\t\t\t\t\twRe = wRe * wMulRe - wIm * wMulIm;\n\t\t\t\t\twIm = tRe * wMulIm + wIm * wMulRe;\n\t\t\t\t}\n\t\t\t\tstart += spacing;\n\t\t\t}\n\t\t\tnumFlies >>= 1;\n\t\t\tspan >>= 1;\n\t\t\tspacing >>= 1;\n\t\t}\n\n\t\tvar revI, buf, m_revTgt = obj.m_revTgt;\n\t\tfor(var i1=0; i1<m_N; i1++)\n\t\t\tif(m_revTgt[i1] > i1) {\n                // Bit-Reversal is an involution i.e.\n                // x.revTgt.revTgt==x\n                // So switching values around\n                // restores the original order\n\t\t\t\trevI = m_revTgt[i1];\n\t\t\t\tbuf = m_re[revI];\n\t\t\t\tm_re[revI] = m_re[i1];\n\t\t\t\tm_re[i1] = buf;\n\t\t\t\tbuf = m_im[revI];\n\t\t\t\tm_im[revI] = m_im[i1];\n\t\t\t\tm_im[i1] = buf;\n\t\t\t}\n\t}\n\n\tvar m_N2 = m_N >> 1; // m_N/2 needed in un/repack below\n\n\t// Two-for-one trick for real-valued FFT:\n\t// Put one series in re, other in im, run \"inplace\",\n\t// then call this \"unpack\" function\n\tobj.unpack = function(rre,rim,ire,iim) {\n\t\trre[0] = obj.m_re[0]; ire[0] = obj.m_im[0];\n\t\trim[0] = iim[0] = 0;\n\t\trre[m_N2] = obj.m_re[m_N2];\n\t\tire[m_N2] = obj.m_im[m_N2];\n\t\trim[m_N2] = iim[m_N2] = 0;\n\t\tfor(var i = 1;i<m_N2;i++) {\n\t\t\trre[i] = (obj.m_re[i] + obj.m_re[m_N - i]) / 2;\n\t\t\trim[i] = (obj.m_im[i] - obj.m_im[m_N - i]) / 2;\n\t\t\tire[i] = (obj.m_im[i] + obj.m_im[m_N - i]) / 2;\n\t\t\tiim[i] = (-obj.m_re[i] + obj.m_re[m_N - i]) / 2;\n\t\t}\n\t}\n\t\n\t// The two-for-one trick if you know results are real-valued\n\t// Call \"repack\", then fft.inplace(true) and you have\n\t// First fft in re and second in im\n\tobj.repack = function(rre,rim,ire,iim) {\n\t\tobj.m_re[0] = rre[0]; obj.m_im[0] = ire[0];\n\t\tobj.m_re[m_N2] = rre[m_N2]; obj.m_im[m_N2] = ire[m_N2];\n\t\tfor(var i = 1;i<m_N2;i++) {\n\t\t\tobj.m_re[i] = rre[i] - iim[i];\n\t\t\tobj.m_im[i] = rim[i] + ire[i];\n\t\t\tobj.m_re[m_N - i] = rre[i] + iim[i];\n\t\t\tobj.m_im[m_N - i] = -rim[i] + ire[i];\n\t\t}\n\t}\n\n\treturn obj;\n};\n\nmodule.exports = FFT;\n\n/***/ })\n/******/ ]);\n});"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 1);\n","\n// Define an allocator and blit function for float arrays\n// Can be used to achieve backwards compatibility down to dark ages pre IE 10 if needed\n// Also reduces code size a little with closure.\n\nvar VH = { \n\tfloat_array: function(len) { return new Float32Array(len); },\n\tblit: function(src, spos, dest, dpos, len) { dest.set(src.subarray(spos,spos+len),dpos); }\n};\n\n// Pre-IE10 versions:\n/*VH.prototype.float_array = function(len) { return new Array(len); }\nVH.prototype.blit = function(src, spos, dest, dpos, len) { for(var i=0;i<len;i++) dest[dpos+i] = src[spos+i]; };*/\n\nmodule.exports = VH;","(function() {\n\n\t/*\n\t * Phase Vocoder for changing tempo of audio without affecting pitch\n\t * Originally cross-compiled from HaXe\n\t *\n\t * Copyright (c) 2015-2019 Margus Niitsoo\n\t */\n\n\tvar VH = require('./vector_helper.js');\n\tvar FFT = require('./fft.js');\n\n\tvar PhaseVocoder = function(opts) {\n\n\t\t/**************************\n\t\t* Fill in sensible defaults\n\t\t**************************/\n\n\t\topts = opts || {};\n\t\tvar sampleRate = opts.sampleRate || 44100;\n\t\tvar wsizeLog = opts.wsizeLog || 12; // 4096\n\t\tvar chosen_tempo = opts.tempo || 1.0;\n\t\tvar numChannels = opts.numChannels || 2;\n\n\t\t/**************************\n\t\t* Initialize variables\n\t\t**************************/\n\n\t\t// Some constants\n\t\tvar GAIN_DEAMPLIFY = 0.9; // Slightly lower the volume to avoid volume overflow-compression\n\t\tvar MAX_PEAK_RATIO = 1e-8; // Do not find peaks below this level: 80dB from max\n\t\tvar MAX_PEAK_JUMP = (Math.pow(2.0,50/1200.0)-1.0); // Rel distance (in freq) to look for matches\n\t\tvar MATCH_MAG_THRESH = 0.1; // New if mag_prev < MATCH_MAG_THRESH * mag_new\n\t\t\n\t\tvar windowSize = 1 << wsizeLog;\n\t\tvar fft = FFT(wsizeLog);\n\n\t\t// Caluclate max step size for both ana and syn windows\n\t\t// Has to be < 1/4 of window length or audible artifacts occur\n\t\tvar max_step_len = 1 << (wsizeLog - 2); // 1/4 of window_size\n\t\tmax_step_len -= max_step_len % 100; // Change to a multiple of 100 as tempo is often changed in percents\n\n\t\t//console.log(\"MAX STEP\",max_step_len,windowSize);\n\t\tvar in_buffer = VH.float_array(windowSize + max_step_len + 5);\n\t\tvar out_buffer = VH.float_array(windowSize + max_step_len + 5);\n\t\tvar ana_len = max_step_len, syn_len = max_step_len;\n\n\t\t// Hanning window\n\t\tvar win = VH.float_array(windowSize);\n\t\tfor(var i=0;i<windowSize;i++)\n\t\t\twin[i] = 0.5 * (1 - Math.cos(2 * Math.PI * i / windowSize));\n\n\t\tvar hWS = (windowSize >> 1) + 1;\n\t\tvar re1 = VH.float_array(hWS), im1 = VH.float_array(hWS);\n\t\tvar re2 = VH.float_array(hWS), im2 = VH.float_array(hWS);\n\t\tvar pre2 = VH.float_array(hWS), pim2 = VH.float_array(hWS);\n\n\t\tvar qWS = (hWS >> 1) + 1;\n\t\tvar b_npeaks = [0,0], b_peaks = [], b_in_angs = [], b_peak_adeltas = [];\n\t\tvar b_mags = [];\n\t\tfor(var i=0;i<2;i++) { // Double buffering\n\t\t\tb_peaks.push(VH.float_array(qWS));\n\t\t\tb_in_angs.push(VH.float_array(qWS));\n\t\t\tb_peak_adeltas.push(VH.float_array(qWS));\n\t\t\tb_mags.push(VH.float_array(hWS));\n\t\t}\n\t\t\n\t\tvar peaks_re = VH.float_array(qWS), peaks_im = VH.float_array(qWS);\n\n\t\t// Keep track of time (in samples) in both input and output streams\n\t\tvar in_time = 0.0, out_time = 0.0;\n\n\t\t// Track the changes for mapOutputToInputTime\n\t\tvar changes = [{ in_time: 0.0, out_time: 0.0, tempo: chosen_tempo }];\n\n\t\tvar f_ind = 0, prev_out_len = 0, gain_comp = 1.0;\n\t\tvar syn_drift = 0.0, syn_drift_per_step = 0.0;\n\n\t\tvar obj = { };\n\n\t\t// Should map time in output to time in input\n\t\tobj['mapOutputToInputTime'] = function(given_out_time) {\n\t\t\tvar ci = changes.length-1;\n\t\t\twhile(given_out_time<changes[ci].out_time && ci>0) ci--;\n\t\t\tvar cc = changes[ci];\n\t\t\treturn cc.in_time + cc.tempo*(given_out_time-cc.out_time);\n\t\t};\n\n\t\tobj['flush'] = function(discard_output_seconds) {\n\t\t\tf_ind = 0;\tprev_out_len = 0;\n\t\t\tsyn_drift = 0.0; b_npeaks = [0,0];\n\n\t\t\tfor(var i=0;i<2;i++)\n\t\t\t\tfor(var k=0;k<hWS;k++)\n\t\t\t\t\tb_mags[i][k] = 0.0;\n\n\t\t\tfor(var i=0;i<in_buffer.length;i++) in_buffer[i] = 0.0;\n\t\t\tfor(var i=0;i<out_buffer.length;i++) out_buffer[i] = 0.0;\n\n\t\t\t// Scroll time cursor back by discard_output_seconds\n\t\t\tif (discard_output_seconds) {\n\n\t\t\t\t// Scroll back time in both coordinates\n\t\t\t\tout_time = Math.max(0,out_time-discard_output_seconds);\n\t\t\t\tin_time = obj['mapOutputToInputTime'](out_time);\n\n\t\t\t\t// Clear the now-made-future tempo changes (if any)\n\t\t\t\tvar ci = changes.length-1;\n\t\t\t\twhile(out_time<=changes[ci].out_time && ci>=0) { changes.pop(); ci--; }\n\n\t\t\t\t// Add a tempo change reflecting current state\n\t\t\t\tchanges.push({ \n\t\t\t\t\tin_time: in_time, out_time: out_time,\n\t\t\t\t\ttempo: chosen_tempo\n\t\t\t\t})\n\t\t\t}\n\t\t};\n\n\t\t// Small utility function to calculate gain compensation\n\t\tvar compute_gain_comp = function(win,syn_len) {\n\t\t\tvar n = win.length / syn_len | 0, sum = 0.0;\n\t\t\tfor(var i=0;i<n;i++) sum += win[i * syn_len];\n\t\t\treturn GAIN_DEAMPLIFY / sum;\n\t\t};\n\t\t\n\t\tobj['getTempo'] = function() { return chosen_tempo; };\n\t\tobj['setTempo'] = function(tempo_ratio) {\n\t\t\tana_len = syn_len = max_step_len;\n\t\t\tif(tempo_ratio >= 1.0) {\n\t\t\t\tsyn_len = Math.round(ana_len / tempo_ratio);\n\t\t\t} else {\n\t\t\t\tana_len = Math.round(syn_len * tempo_ratio);\n\t\t\t}\n\t\t\tsyn_drift_per_step = (1.0 / tempo_ratio - 1.0 * syn_len / ana_len) * ana_len;\n\t\t\tgain_comp = compute_gain_comp(win,syn_len);\n\t\t\tchosen_tempo = tempo_ratio;\n\t\t\t//console.log(\"TEMPO CHANGE\",tempo_ratio,\"LENS\",ana_len,syn_len,\"GAIN\",gain_comp);\n\n\t\t\t// Handle book-keeping for time map\n\t\t\tvar lc = changes[changes.length-1];\n\t\t\tif (lc.out_time == out_time) // no samples since last change\n\t\t\t\tlc.tempo = tempo_ratio; // Just replace last change event\n\t\t\telse //add new entry\n\t\t\t\tchanges.push({ \n\t\t\t\t\tin_time: in_time, out_time: out_time,\n\t\t\t\t\ttempo: tempo_ratio\n\t\t\t\t})\n\t\t};\n\n\t\tobj['flush'](0); obj['setTempo'](chosen_tempo);\n\n\n\t\t/**************************\n\t\t* Small utility functions\n\t\t**************************/\n\t\t\n\t\t// Estimate the phase at (fractional) fft bin ind\n\t\tvar interpolate_phase = function(re,im,ind) {\n\t\t\tvar i = Math.floor(ind);\n\t\t\tvar sgn = i % 2 == 1 ? -1.0 : 1.0;\n\t\t\treturn Math.atan2(sgn * (im[i] - im[i + 1]),sgn * (re[i] - re[i + 1]));\n\t\t};\n\n\t\t// Get ang between -PI and PI\n\t\tvar unwrap = function(ang) {\n\t\t\treturn ang - 2 * Math.PI * Math.round(ang / (2 * Math.PI) );\n\t\t};\n\n\t\t// Try to estimate the phase change if window lengths differ by ratio\n\t\tvar estimate_phase_change = function(ang,k,pang,pk,ratio) {\n\t\t\tvar pred = 2 * Math.PI / windowSize * 0.5 * (pk + k) * ana_len;\n\t\t\tvar ywang = unwrap(ang - pang - pred);\n\n\t\t\treturn (ywang + pred) * ratio;\n\t\t};\n\n\t\t/**************************\n\t\t* Find peaks of spectrum\n\t\t**************************/\n\n\t\tvar find_rpeaks = function(mags,res) {\n\n\t\t\tvar max = 0; for(var i=0;i<mags.length;i++) if (mags[i]>max) max=mags[i];\n\t\t\tvar thresh = MAX_PEAK_RATIO * max;\n\n\t\t\tvar n_peaks = 1, prev_pi = 1; res[0] = 1.0;\n\t\t\tfor(var i=2;i<mags.length;i++) {\n\t\t\t\tvar f_delta = i * MAX_PEAK_JUMP;\n\t\t\t\tif(mags[i]>thresh && mags[i] > mags[i - 1] && mags[i] >= mags[i + 1]) { // Is local peak\n\n\t\t\t\t\t// Use quadratic interpolation to fine-tune the peak location\n\t\t\t\t\tvar ppos = i + (mags[i - 1] - mags[i + 1]) / (2 * (mags[i - 1] - 2 * mags[i] + mags[i + 1]));\n\n\t\t\t\t\t// If far enough from previous peak, add to list\n\t\t\t\t\tif(ppos - res[n_peaks - 1] > f_delta) { res[n_peaks++] = ppos; prev_pi = i; }\n\t\t\t\t\t// Else, if not far enough, but higher than previous, just replace prev \n\t\t\t\t\telse if(mags[i] > mags[prev_pi]) { res[n_peaks - 1] = ppos;\tprev_pi = i; }\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn n_peaks;\n\t\t};\n\n\t\t/**************************\n\t\t* Rigid phase shift\n\t\t**************************/\n\n\t\tvar pshift_rigid = function(frame_ind,re,im,p_re,p_im,ratio) {\n\t\t\tvar CUR = frame_ind % 2, PREV = 1 - CUR;\n\n\t\t\tvar prev_mags = b_mags[PREV];\n\n\t\t\tvar prev_np = b_npeaks[PREV], prpeaks = b_peaks[PREV];\n\t\t\tvar prev_in_angs = b_in_angs[PREV], prev_peak_adeltas = b_peak_adeltas[PREV];\n\n\t\t\t// Calc new mags\n\t\t\tvar mags = b_mags[CUR];\n\t\t\tfor(var i=1;i<mags.length;i++) mags[i] = re[i] * re[i] + im[i] * im[i];\n\t\t\n\t\t\t// Find new peaks\n\t\t\tvar peaks = b_peaks[CUR];\n\t\t\tvar cur_np = b_npeaks[CUR] = find_rpeaks(mags,peaks);\n\n\t\t\t// Start adjusting angles\n\t\t\tvar cur_in_angs = b_in_angs[CUR], cur_peak_adeltas = b_peak_adeltas[CUR];\n\n\t\t\tif(frame_ind == 0 || cur_np == 0) { // If first frame (or no peaks)\n\n\t\t\t\t// Set out_ang = in_ang for all peaks\n\t\t\t\tfor(var ci=0;ci<cur_np;ci++) {\n\t\t\t\t\tvar pci = peaks[ci];\n\t\t\t\t\tprev_in_angs[ci] = prev_peak_adeltas[ci] = interpolate_phase(re,im,pci);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t    /*********************************************************\n\t    \t* Match old peaks with new ones\n\t    \t* Also find where pmag*mag is max for next step\n\t    \t*********************************************************/\n\n\t\t\tvar pi = 0;\n\t\t\tfor(var ci=0;ci<cur_np;ci++) {\n\t\t\t\tvar pci = peaks[ci];\n\n\t\t\t\t// Scroll so peaks[ci] is between prpeaks[pi] and prpeaks[pi+1]\n\t\t\t\twhile(peaks[ci] > prpeaks[pi] && pi != prev_np) ++pi;\n\n\t\t\t\tvar cpi = pi;\n\t\t\t\tif(pi > 0 && pci - prpeaks[pi - 1] < prpeaks[pi] - pci) cpi = pi - 1;\n\n\t\t\t\tvar peak_delta = pci * MAX_PEAK_JUMP;\n\t\t\t\tif(Math.abs(prpeaks[cpi] - pci) < peak_delta && \n\t\t\t\t\tprev_mags[Math.round(prpeaks[cpi])] > \n\t\t\t\t\t\tMATCH_MAG_THRESH * mags[Math.round(pci)]) {\n\n\t\t\t\t\t// Found a matching peak in previous frame, so predict based on the diff\n\t\t\t\t\tvar in_angle = interpolate_phase(re,im,pci);\n\t\t\t\t\tvar out_angle = prev_in_angs[cpi] + prev_peak_adeltas[cpi] +\n\t\t\t\t\t\t\testimate_phase_change(in_angle,pci,prev_in_angs[cpi],prpeaks[cpi],ratio);\n\n\t\t\t\t\tvar delta = out_angle - in_angle;\n\t\t\t\t\tcur_in_angs[ci] = in_angle; cur_peak_adeltas[ci] = delta;\n\t\t\t\t\tpeaks_re[ci] = Math.cos(delta);\tpeaks_im[ci] = Math.sin(delta);\n\t\t\t\t} else { // Not matched - use the same phase as input\n\t\t\t\t\tcur_in_angs[ci] = interpolate_phase(re,im,pci);\n\t\t\t\t\tcur_peak_adeltas[ci] = 0; peaks_re[ci] = 1.0;\tpeaks_im[ci] = 0.0;\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\n\t\t    /********************************************************\n\t\t    * Adjust phase of all bins based on closest peak\n\t\t    *********************************************************/\n\n\t\t    // Add a \"dummy\" peak at the end of array\n\t\t\tpeaks[cur_np] = 2 * windowSize;\n\t\t\t\n\t\t\tvar cpi = 0, cp = peaks[cpi], cnp = peaks[cpi + 1];\n\t\t\tvar cre = peaks_re[cpi], cim = peaks_im[cpi];\n\n\t\t\tfor(var i=1;i<re.length-1;i++) {\n\t\t\t\tif(i >= cp && i - cp > cnp - i) {\n\t\t\t\t\t++cpi; cp = peaks[cpi];\tcnp = peaks[cpi + 1];\n\t\t\t\t\tcre = peaks_re[cpi]; cim = peaks_im[cpi];\n\t\t\t\t}\n\n\t\t\t\tvar nre = re[i] * cre - im[i] * cim;\n\t\t\t\tvar nim = re[i] * cim + im[i] * cre;\n\t\t\t\tre[i] = nre; im[i] = nim;\n\t\t\t}\n\t\t}\n\n\t\t/***********************************\n\t\t* Perform two syn/ana steps \n\t\t*\t(using the two-for-one fft trick)\n\t  \t* Takes windowSize + ana_len samples from in_buffer\n\t  \t*   and shifts in_buffer back by 2*ana_len\n\t  \t* Outputs <retval> samples to out_buffer\n\t\t***********************************/\n\n\t\tvar two_steps = function() {\n\n\t\t\t// To better match the given ratio,\n\t    \t// occasionally tweak syn_len by 1 or 2\n\t\t\tsyn_drift += 2 * syn_drift_per_step;\n\t\t\tvar sdelta = syn_drift | 0;\n\t\t\tsyn_drift -= sdelta;\n\t\t\t\n\t\t\t// Pack two steps into fft object\n\t\t\tfor(var i=0;i<windowSize;i++) {\n\t\t\t\tfft.m_re[i] = win[i] * in_buffer[i];\n\t\t\t\tfft.m_im[i] = win[i] * in_buffer[ana_len + i];\n\t\t\t}\n\n\t\t\t// Shift in_buffer back by 2*ana_len\n\t\t\tVH.blit(in_buffer,2*ana_len,\n\t            in_buffer,0,windowSize-ana_len);\n\n\t\t\t// Run the fft\n\t\t\tfft.inplace(false);\n\t\t\tfft.unpack(re1,im1,re2,im2);\n\n\t\t\t// Step 1 - move by syn_len\n\t\t\tvar ratio1 = 1.0 * syn_len / ana_len;\n\t\t\tpshift_rigid(f_ind,re1,im1,pre2,pim2,ratio1);\n\n\t\t\t// Step 2 - move by syn_len+sdelta\n\t\t\tvar ratio2 = 1.0 * (syn_len + sdelta) / ana_len;\n\t\t\tpshift_rigid(f_ind + 1,re2,im2,re1,im1,ratio2);\n\n\t\t\t// Save (modified) re and im\n\t\t\tVH.blit(re2,0,pre2,0,hWS); VH.blit(im2,0,pim2,0,hWS);\n\n\t\t\t// Run ifft\n\t\t\tfft.repack(re1,im1,re2,im2);\n\t\t\tfft.inplace(true);\n\n\t\t\t// Shift out_buffer back by previous out_len;\n\t\t\tvar oblen = out_buffer.length;\n\t\t\tVH.blit(out_buffer,prev_out_len,\n\t            out_buffer,0,oblen-prev_out_len);\n\t\t\t\n\t\t\t// And shift in zeros at the end\n\t\t\tfor(var i=oblen-prev_out_len;i<oblen;i++) out_buffer[i] = 0.0;\n\t\t\t\n\t\t\t// Value overflow protection - scale the packet if max above a threshold\n\t\t    // The distortion this creates is insignificant compared to phase issues\n\t\t\tvar max = 0.0, gc = gain_comp;\n\t\t\tfor(var i=0;i<syn_len;i++)\n\t\t\t\tif(Math.abs(2 * fft.m_re[i]) > max)\n\t\t\t\t\tmax = Math.abs(2 * fft.m_re[i]);\n\t\t\tfor(var i=0;i<windowSize-syn_len;i++)\n\t\t\t\tif(Math.abs(fft.m_re[i + syn_len + sdelta] + fft.m_im[i]) > max)\n\t\t\t\t\tmax = Math.abs(fft.m_re[i + syn_len + sdelta] + fft.m_im[i]);\n\n\t\t\tfor(var i=windowSize-syn_len;i<windowSize;i++)\n\t\t\t\tif(Math.abs(2 * fft.m_im[i]) > max)\n\t\t\t\t\tmax = Math.abs(2 * fft.m_im[i]);\n\n\t\t\t// Find allowed ceiling of a two-step sum and lower gain if needed\n\t\t\tvar ceiling = 1.0 / Math.floor(1.0 * windowSize / (2 * syn_len));\n\t\t\tif(gc * max > ceiling) {\n\t\t\t\t//console.log(\"Gain overflow, lowering volume: \",ceiling / max,gc,max);\n\t\t\t\tgc = ceiling / max;\n\t\t\t}\n\n\t\t\t// Write results to out_buffer\n\t\t\tfor(var i=0;i<windowSize;i++) {\n\t\t\t\tout_buffer[i] += gc * fft.m_re[i];\n\t\t\t\tout_buffer[i + syn_len + sdelta] += gc * fft.m_im[i];\n\t\t\t}\n\n\t\t\tf_ind += 2;\tprev_out_len = 2 * syn_len + sdelta;\n\n\t\t\treturn prev_out_len;\n\t\t}\n\n\t\t// Two variables used for \"process\"\n\t\tvar inbuffer_contains = 0, unused_in_outbuf = 0;\n\n\t\t// input: array of channels, each a float_array with unbounded amount of samples\n\t\t// output: same format\n\t\tobj['process'] = function(in_ar) {\n\n\t\t\t// Mix channels together (if needed)\n\t\t\tvar mix = in_ar[0], in_len = in_ar[0].length; \n\t\t\tif (in_ar.length>1) {\n\t\t\t\tmix = VH.float_array(in_ar[0].length);\n\t\t\t\tvar mult = 1.0/in_ar.length;\n\t\t\t\tfor(var c=0;c<in_ar.length;c++)\n\t\t\t\t\tfor(var i=0;i<in_len;i++)\n\t\t\t\t\t\tmix[i] += mult*in_ar[c][i];\n\t\t\t}\n\n\t\t\t// Calculate output length\n\t\t\t// Should underestimate, and by no more than 4, which can easily fit in the unused_in_outbuf\n\t\t\tvar consumable_samples = inbuffer_contains + in_len - (windowSize - ana_len);\n\t\t\tvar n_steps = 2*Math.floor(Math.max(0,consumable_samples)/(2*ana_len));\n\t\t\tvar out_len = unused_in_outbuf + syn_len*n_steps +\n\t\t\t\t\t\t\tMath.floor(syn_drift+syn_drift_per_step*n_steps);\n\n\t\t\tif (unused_in_outbuf>out_len) out_len = unused_in_outbuf;\n\n\t\t\t// Allocate output\n\t\t\tvar outp = VH.float_array(out_len);\n\n\t\t\t// Copy previously unused but ready values to output\n\t\t\tVH.blit(out_buffer,0,outp,0,unused_in_outbuf); \n\t\t\tvar ii = 0, oi = unused_in_outbuf;\n\t\t\t\n\t\t\tvar left_over = 0, res_len = 0;\n\t\t\twhile(true) {\n\n\t\t\t\t// Calculate how many new samples we need to call two_steps\n\t\t\t\tvar n_needed = windowSize + ana_len - inbuffer_contains;\n\t\t\t\t\n\t\t\t\tif (ii+n_needed>in_len) { // Not enough samples for next step\n\t\t\t\t\t// Copy whats left to inbuffer and break out of the loop\n\t\t\t\t\tVH.blit(mix,ii,in_buffer,inbuffer_contains,in_len-ii);\n\t\t\t\t\tinbuffer_contains += in_len-ii; ii = in_len;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if (n_needed <= 0) // Already enough - can happen if tempo changed\n\t\t\t\t\tinbuffer_contains -= 2 * ana_len; \n\t\t\t\telse { // Main case - we have enough\n\t\t\t\t\t// Copy over this many samples from input\n\t\t\t\t\tVH.blit(mix,ii,in_buffer,inbuffer_contains,n_needed);\n\t\t\t\t\tii += n_needed;\t\t\t\t\t\n\t\t\t\t\tinbuffer_contains = windowSize - ana_len;\n\t\t\t\t}\n\n\t\t\t\t// Invariant: left_over should be 0 here as it should break!\n\n\t\t\t\t// Run the vocoder\n\t\t\t\tres_len = two_steps();\n\n\t\t\t\t// Move time pointers\n\t\t\t\tin_time += 2*ana_len/sampleRate; out_time += res_len/sampleRate;\n\n\t\t\t\t// Calculate how many samples are left over (usually 0)\n\t\t\t\tleft_over = oi + res_len - out_len; if(left_over < 0) left_over = 0;\n\n\t\t\t\t// Copy fully ready samples out\n\t\t        VH.blit(out_buffer,0,outp,oi,res_len-left_over);\n\n\t\t\t\toi += res_len;\n\t\t\t}\n\n\t\t\t// Copy left over samples to the beginning of out_buffer\n  \t\t\tVH.blit(out_buffer,res_len-left_over,out_buffer,0,left_over);\n  \t\t\tunused_in_outbuf = left_over;\n\n  \t\t\t//////////////////////// DONE\n\n\t\t\t// Clone the result to match the number of input channels\n\t\t\tvar out_ar = [];\n\t\t\tfor(var c=0;c<in_ar.length;c++) out_ar.push(outp);\n\n\t\t\treturn out_ar;\n\t\t};\n\n\t\treturn obj;\n\t};\n\n\t/** @export */\n\tmodule.exports = PhaseVocoder;\n})();\n","'use strict';\n\n/*\n * Performs an in-place complex FFT.\n * Adapted from FFT for ActionScript 3 written by Gerald T. Beauregard \n * (original ActionScript3 version, http://gerrybeauregard.wordpress.com/2010/08/03/an-even-faster-as3-fft/)\n *\n * Copyright (c) 2015-2019 Margus Niitsoo\n */\n\nvar VH = require('./vector_helper.js');\n\nvar FFT = function(logN) {\n\n\t// Size of the buffer\n\tvar m_N = 1 << logN;\n\n\n\tvar obj = {\n\t\tm_logN : logN, m_N : m_N,\n\t\tm_invN : 1.0 / m_N,\n\t\tm_re : VH.float_array(m_N),\n\t\tm_im : VH.float_array(m_N),\n\t\tm_revTgt : new Array(m_N)\n\t}\n\n\t// Calculate bit reversals\n\tfor(var k = 0; k<m_N; k++) {\n\t\tvar x = k, y = 0;\n\t\tfor(var i=0;i<logN;i++) {\n\t\t\ty <<= 1;\n\t\t\ty |= x & 1;\n\t\t\tx >>= 1;\n\t\t}\n\t\tobj.m_revTgt[k] = y;\n\t}\n\n    // Compute a multiplier factor for the \"twiddle factors\".\n    // The twiddle factors are complex unit vectors spaced at\n    // regular angular intervals. The angle by which the twiddle\n    // factor advances depends on the FFT stage. In many FFT\n    // implementations the twiddle factors are cached.\n\n\tobj.twiddleRe = VH.float_array(obj.m_logN);\n\tobj.twiddleIm = VH.float_array(obj.m_logN);\n\n\tvar wIndexStep = 1;\n\tfor(var stage = 0; stage<obj.m_logN; stage++) {\n\t\tvar wAngleInc = 2.0 * wIndexStep * Math.PI * obj.m_invN;\n\t\tobj.twiddleRe[stage] = Math.cos(wAngleInc);\n\t\tobj.twiddleIm[stage] = Math.sin(wAngleInc);\n\t\twIndexStep <<= 1;\n\t}\n\n\t// In-place FFT function\n\tobj.inplace = function(inverse) {\n\n\t\tvar m_re = obj.m_re, m_im = obj.m_im;\n\t\tvar m_N = obj.m_N, m_logN = obj.m_logN;\n\n\t\tvar numFlies = m_N >> 1;\n\t\tvar span = m_N >> 1;\n\t\tvar spacing = m_N;\n\n\t\tif(inverse) {\n\t\t\tvar m_invN = 1.0/m_N;\n\t\t\tfor(var i=0; i<m_N; i++) {\n\t\t\t\tm_re[i] *= m_invN;\n\t\t\t\tm_im[i] *= m_invN;\n\t\t\t}\n\t\t}\n\n\t\t// For each stage of the FFT\n\t\tfor(var stage=0; stage<m_logN; stage++) {\n\t\t\tvar wMulRe = obj.twiddleRe[stage];\n\t\t\tvar wMulIm = obj.twiddleIm[stage];\n\t\t\tif(!inverse) wMulIm *= -1;\n\n\t\t\tvar start = 0;\n\t\t\twhile(start < m_N) {\n\t\t\t\tvar iTop = start, iBot = start + span;\n\t\t\t\tvar wRe = 1.0, wIm = 0.0;\n\n\t\t\t\t// For each butterfly in this stage\n\t\t\t\tfor(var flyCount=0; flyCount<numFlies; flyCount++) {\n\t\t\t\t\t// Get the top & bottom values\n\t\t\t\t\tvar xTopRe = m_re[iTop];\n\t\t\t\t\tvar xTopIm = m_im[iTop];\n\t\t\t\t\tvar xBotRe = m_re[iBot];\n\t\t\t\t\tvar xBotIm = m_im[iBot];\n\n\t\t\t\t\t// Top branch of butterfly has addition\n\t\t\t\t\tm_re[iTop] = xTopRe + xBotRe;\n\t\t\t\t\tm_im[iTop] = xTopIm + xBotIm;\n\n\t\t\t\t\t// Bottom branch of butterly has subtraction,\n                    // followed by multiplication by twiddle factor\n\t\t\t\t\txBotRe = xTopRe - xBotRe;\n\t\t\t\t\txBotIm = xTopIm - xBotIm;\n\n\t\t\t\t\tm_re[iBot] = xBotRe * wRe - xBotIm * wIm;\n\t\t\t\t\tm_im[iBot] = xBotRe * wIm + xBotIm * wRe;\n\n\t\t\t\t\t// Advance butterfly to next top & bottom positions\n                    iTop++;\n                    iBot++;\n\n                    // Update the twiddle factor, via complex multiply\n                    // by unit vector with the appropriate angle\n                    // (wRe + j wIm) = (wRe + j wIm) x (wMulRe + j wMulIm)\n\t\t\t\t\tvar tRe = wRe;\n\t\t\t\t\twRe = wRe * wMulRe - wIm * wMulIm;\n\t\t\t\t\twIm = tRe * wMulIm + wIm * wMulRe;\n\t\t\t\t}\n\t\t\t\tstart += spacing;\n\t\t\t}\n\t\t\tnumFlies >>= 1;\n\t\t\tspan >>= 1;\n\t\t\tspacing >>= 1;\n\t\t}\n\n\t\tvar revI, buf, m_revTgt = obj.m_revTgt;\n\t\tfor(var i1=0; i1<m_N; i1++)\n\t\t\tif(m_revTgt[i1] > i1) {\n                // Bit-Reversal is an involution i.e.\n                // x.revTgt.revTgt==x\n                // So switching values around\n                // restores the original order\n\t\t\t\trevI = m_revTgt[i1];\n\t\t\t\tbuf = m_re[revI];\n\t\t\t\tm_re[revI] = m_re[i1];\n\t\t\t\tm_re[i1] = buf;\n\t\t\t\tbuf = m_im[revI];\n\t\t\t\tm_im[revI] = m_im[i1];\n\t\t\t\tm_im[i1] = buf;\n\t\t\t}\n\t}\n\n\tvar m_N2 = m_N >> 1; // m_N/2 needed in un/repack below\n\n\t// Two-for-one trick for real-valued FFT:\n\t// Put one series in re, other in im, run \"inplace\",\n\t// then call this \"unpack\" function\n\tobj.unpack = function(rre,rim,ire,iim) {\n\t\trre[0] = obj.m_re[0]; ire[0] = obj.m_im[0];\n\t\trim[0] = iim[0] = 0;\n\t\trre[m_N2] = obj.m_re[m_N2];\n\t\tire[m_N2] = obj.m_im[m_N2];\n\t\trim[m_N2] = iim[m_N2] = 0;\n\t\tfor(var i = 1;i<m_N2;i++) {\n\t\t\trre[i] = (obj.m_re[i] + obj.m_re[m_N - i]) / 2;\n\t\t\trim[i] = (obj.m_im[i] - obj.m_im[m_N - i]) / 2;\n\t\t\tire[i] = (obj.m_im[i] + obj.m_im[m_N - i]) / 2;\n\t\t\tiim[i] = (-obj.m_re[i] + obj.m_re[m_N - i]) / 2;\n\t\t}\n\t}\n\t\n\t// The two-for-one trick if you know results are real-valued\n\t// Call \"repack\", then fft.inplace(true) and you have\n\t// First fft in re and second in im\n\tobj.repack = function(rre,rim,ire,iim) {\n\t\tobj.m_re[0] = rre[0]; obj.m_im[0] = ire[0];\n\t\tobj.m_re[m_N2] = rre[m_N2]; obj.m_im[m_N2] = ire[m_N2];\n\t\tfor(var i = 1;i<m_N2;i++) {\n\t\t\tobj.m_re[i] = rre[i] - iim[i];\n\t\t\tobj.m_im[i] = rim[i] + ire[i];\n\t\t\tobj.m_re[m_N - i] = rre[i] + iim[i];\n\t\t\tobj.m_im[m_N - i] = -rim[i] + ire[i];\n\t\t}\n\t}\n\n\treturn obj;\n};\n\nmodule.exports = FFT;"],"sourceRoot":""}